{
  "id": "oop-01",
  "title": "Introduction to OOP",
  "category": "Object-Oriented Programming",
  "number": 58,
  "duration": "8 min read",
  "content": "## What is Object-Oriented Programming?\n\nObject-Oriented Programming (OOP) is a programming paradigm that organizes code around **objects** rather than functions and logic. It models real-world entities as software objects that contain both data and behavior.\n\n## The Four Pillars of OOP\n\nOOP is built on four fundamental principles:\n\n### 1. Encapsulation\n\nBundling data (attributes) and methods (functions) that operate on that data within a single unit (class). This hides internal details and protects data from unauthorized access.\n\n```python\nclass BankAccount:\n    def __init__(self, balance):\n        self._balance = balance  # Protected attribute\n    \n    def deposit(self, amount):\n        self._balance += amount\n    \n    def get_balance(self):\n        return self._balance\n```\n\n### 2. Abstraction\n\nHiding complex implementation details and showing only the necessary features. Users interact with a simplified interface.\n\n```python\nclass Car:\n    def start(self):\n        self._check_battery()\n        self._inject_fuel()\n        self._ignite_engine()\n        print(\"Car started!\")\n    \n    def _check_battery(self):\n        pass  # Hidden complexity\n```\n\n### 3. Inheritance\n\nCreating new classes based on existing classes. Child classes inherit attributes and methods from parent classes.\n\n```python\nclass Animal:\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n```\n\n### 4. Polymorphism\n\nObjects of different classes can be treated as objects of a common parent class. The same method can behave differently for different classes.\n\n```python\ndef make_speak(animal):\n    print(animal.speak())  # Works for any Animal subclass\n\nmake_speak(Dog())   # Woof!\nmake_speak(Cat())   # Meow!\n```\n\n## Why Use OOP?\n\n| Benefit | Description |\n|---------|-------------|\n| **Modularity** | Code is organized into self-contained objects |\n| **Reusability** | Classes can be reused across projects |\n| **Maintainability** | Changes to one class don't affect others |\n| **Scalability** | Easy to add new features through inheritance |\n| **Real-world modeling** | Objects mirror real entities naturally |\n\n## Procedural vs OOP\n\n```python\n# Procedural approach\ndef create_dog(name, age):\n    return {\"name\": name, \"age\": age}\n\ndef dog_bark(dog):\n    print(f\"{dog['name']} says Woof!\")\n\nmy_dog = create_dog(\"Buddy\", 3)\ndog_bark(my_dog)\n\n# OOP approach\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def bark(self):\n        print(f\"{self.name} says Woof!\")\n\nmy_dog = Dog(\"Buddy\", 3)\nmy_dog.bark()\n```\n\n## Key Terminology\n\n- **Class**: A blueprint for creating objects\n- **Object**: An instance of a class\n- **Attribute**: Data stored in an object\n- **Method**: A function defined inside a class\n- **Instance**: A specific object created from a class\n- **Constructor**: Special method that initializes objects (`__init__`)",
  "code": "# Introduction to OOP - Comparing Approaches\n\n# Procedural approach\ndef create_person(name, age):\n    return {\"name\": name, \"age\": age}\n\ndef greet_person(person):\n    print(f\"Hello, I'm {person['name']}!\")\n\n# OOP approach\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def greet(self):\n        print(f\"Hello, I'm {self.name}!\")\n\n# Try both approaches\nperson1 = create_person(\"Alice\", 30)\ngreet_person(person1)\n\nperson2 = Person(\"Bob\", 25)\nperson2.greet()\n\n# Notice how OOP keeps data and behavior together\nprint(f\"\\n{person2.name} is {person2.age} years old\")"
}
