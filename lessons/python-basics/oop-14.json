{
  "id": "oop-14",
  "title": "Magic Methods",
  "category": "Object-Oriented Programming",
  "number": 71,
  "duration": "10 min read",
  "content": "## What are Magic Methods?\n\nMagic methods (also called dunder methods) are special methods surrounded by double underscores. They allow you to define how objects behave with built-in Python operations.\n\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __str__(self):\n        return f\"Point({self.x}, {self.y})\"\n\npoint = Point(3, 4)\nprint(point)  # Point(3, 4)\n```\n\n## String Representation\n\n### `__str__` - User-friendly string\n\n```python\nclass Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n    \n    def __str__(self):\n        return f\"{self.title} by {self.author}\"\n\nbook = Book(\"1984\", \"George Orwell\")\nprint(book)  # 1984 by George Orwell\n```\n\n### `__repr__` - Developer string\n\n```python\nclass Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n    \n    def __repr__(self):\n        return f\"Book('{self.title}', '{self.author}')\"\n\nbook = Book(\"1984\", \"George Orwell\")\nprint(repr(book))  # Book('1984', 'George Orwell')\n```\n\n## Comparison Methods\n\n```python\nclass Money:\n    def __init__(self, amount):\n        self.amount = amount\n    \n    def __eq__(self, other):  # ==\n        return self.amount == other.amount\n    \n    def __lt__(self, other):  # <\n        return self.amount < other.amount\n    \n    def __le__(self, other):  # <=\n        return self.amount <= other.amount\n    \n    def __gt__(self, other):  # >\n        return self.amount > other.amount\n    \n    def __ge__(self, other):  # >=\n        return self.amount >= other.amount\n\nm1 = Money(100)\nm2 = Money(200)\nprint(m1 < m2)   # True\nprint(m1 == m2)  # False\n```\n\n## Arithmetic Methods\n\n```python\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):  # +\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):  # -\n        return Vector(self.x - other.x, self.y - other.y)\n    \n    def __mul__(self, scalar):  # *\n        return Vector(self.x * scalar, self.y * scalar)\n    \n    def __str__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nv1 = Vector(1, 2)\nv2 = Vector(3, 4)\nprint(v1 + v2)  # Vector(4, 6)\nprint(v1 * 3)   # Vector(3, 6)\n```\n\n## Container Methods\n\n```python\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n    \n    def __len__(self):  # len()\n        return len(self.songs)\n    \n    def __getitem__(self, index):  # []\n        return self.songs[index]\n    \n    def __setitem__(self, index, value):  # [] =\n        self.songs[index] = value\n    \n    def __contains__(self, song):  # in\n        return song in self.songs\n    \n    def __iter__(self):  # for loop\n        return iter(self.songs)\n    \n    def add(self, song):\n        self.songs.append(song)\n\nplaylist = Playlist()\nplaylist.add(\"Song A\")\nplaylist.add(\"Song B\")\n\nprint(len(playlist))        # 2\nprint(playlist[0])          # Song A\nprint(\"Song A\" in playlist) # True\n```\n\n## Callable Objects\n\n```python\nclass Multiplier:\n    def __init__(self, factor):\n        self.factor = factor\n    \n    def __call__(self, value):\n        return value * self.factor\n\ndouble = Multiplier(2)\ntriple = Multiplier(3)\n\nprint(double(5))   # 10\nprint(triple(5))   # 15\n```\n\n## Context Managers\n\n```python\nclass Timer:\n    def __enter__(self):\n        import time\n        self.start = time.time()\n        return self\n    \n    def __exit__(self, *args):\n        import time\n        self.elapsed = time.time() - self.start\n        print(f\"Elapsed: {self.elapsed:.4f}s\")\n\nwith Timer():\n    sum(range(1000000))\n```\n\n## Common Magic Methods\n\n| Method | Operator/Function |\n|--------|------------------|\n| `__init__` | Constructor |\n| `__str__` | `str()`, `print()` |\n| `__repr__` | `repr()` |\n| `__len__` | `len()` |\n| `__getitem__` | `obj[key]` |\n| `__setitem__` | `obj[key] = value` |\n| `__contains__` | `in` |\n| `__iter__` | `for` loop |\n| `__call__` | `obj()` |\n| `__add__` | `+` |\n| `__sub__` | `-` |\n| `__mul__` | `*` |\n| `__eq__` | `==` |\n| `__lt__` | `<` |\n| `__hash__` | `hash()` |",
  "code": "# Magic Methods - Practice\n\nclass Money:\n    \"\"\"Currency class with magic methods\"\"\"\n    \n    def __init__(self, amount, currency=\"USD\"):\n        self.amount = round(amount, 2)\n        self.currency = currency\n    \n    # String representations\n    def __str__(self):\n        symbols = {\"USD\": \"$\", \"EUR\": \"\\u20ac\", \"GBP\": \"\\u00a3\"}\n        symbol = symbols.get(self.currency, self.currency)\n        return f\"{symbol}{self.amount:,.2f}\"\n    \n    def __repr__(self):\n        return f\"Money({self.amount}, '{self.currency}')\"\n    \n    # Arithmetic operations\n    def __add__(self, other):\n        if isinstance(other, Money):\n            if self.currency != other.currency:\n                raise ValueError(\"Cannot add different currencies\")\n            return Money(self.amount + other.amount, self.currency)\n        return Money(self.amount + other, self.currency)\n    \n    def __sub__(self, other):\n        if isinstance(other, Money):\n            if self.currency != other.currency:\n                raise ValueError(\"Cannot subtract different currencies\")\n            return Money(self.amount - other.amount, self.currency)\n        return Money(self.amount - other, self.currency)\n    \n    def __mul__(self, factor):\n        return Money(self.amount * factor, self.currency)\n    \n    def __truediv__(self, factor):\n        return Money(self.amount / factor, self.currency)\n    \n    # Comparison operations\n    def __eq__(self, other):\n        return self.amount == other.amount and self.currency == other.currency\n    \n    def __lt__(self, other):\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot compare different currencies\")\n        return self.amount < other.amount\n    \n    def __le__(self, other):\n        return self == other or self < other\n    \n    # Boolean\n    def __bool__(self):\n        return self.amount != 0\n    \n    # Negation\n    def __neg__(self):\n        return Money(-self.amount, self.currency)\n\n# Create money objects\nprint(\"=== Creating Money ===\")\nprice = Money(99.99)\ntax = Money(8.50)\ndiscount = Money(15.00)\n\nprint(f\"Price: {price}\")\nprint(f\"Tax: {tax}\")\nprint(f\"Discount: {discount}\")\n\n# Arithmetic\nprint(\"\\n=== Arithmetic ===\")\ntotal = price + tax - discount\nprint(f\"Total: {price} + {tax} - {discount} = {total}\")\n\ndoubled = price * 2\nprint(f\"Doubled: {price} * 2 = {doubled}\")\n\nsplit = total / 3\nprint(f\"Split 3 ways: {total} / 3 = {split}\")\n\n# Comparisons\nprint(\"\\n=== Comparisons ===\")\na = Money(100)\nb = Money(150)\nprint(f\"{a} < {b}: {a < b}\")\nprint(f\"{a} == {b}: {a == b}\")\nprint(f\"{a} <= Money(100): {a <= Money(100)}\")\n\n# Boolean and negation\nprint(\"\\n=== Boolean and Negation ===\")\nzero = Money(0)\nprint(f\"bool({price}): {bool(price)}\")\nprint(f\"bool({zero}): {bool(zero)}\")\nprint(f\"Negated: -{price} = {-price}\")\n\n# repr for debugging\nprint(\"\\n=== Repr ===\")\nprint(repr(price))"
}
