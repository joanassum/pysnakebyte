{
  "id": "err-02",
  "title": "Try and Except",
  "category": "Error Handling",
  "number": 82,
  "duration": "7 min read",
  "content": "## Try and Except Blocks\n\nThe `try` and `except` statements allow you to catch and handle exceptions gracefully, preventing your program from crashing.\n\n## Basic Syntax\n\n```python\ntry:\n    # Code that might raise an exception\n    risky_operation()\nexcept:\n    # Code to handle the exception\n    print(\"Something went wrong!\")\n```\n\n## Catching Specific Exceptions\n\nAlways catch specific exceptions when possible:\n\n```python\ntry:\n    number = int(input(\"Enter a number: \"))\n    result = 100 / number\n    print(f\"Result: {result}\")\nexcept ValueError:\n    print(\"That's not a valid number!\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n```\n\n## Accessing Exception Information\n\nUse `as` to capture the exception object:\n\n```python\ntry:\n    file = open(\"nonexistent.txt\", \"r\")\nexcept FileNotFoundError as e:\n    print(f\"Error: {e}\")\n    print(f\"Filename: {e.filename}\")\n```\n\n## The Exception Object\n\n```python\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError as e:\n    print(f\"Type: {type(e).__name__}\")\n    print(f\"Args: {e.args}\")\n    print(f\"Message: {str(e)}\")\n```\n\n## Practical Examples\n\n### Safe Division Function\n\n```python\ndef safe_divide(a, b):\n    try:\n        return a / b\n    except ZeroDivisionError:\n        return None\n    except TypeError:\n        return None\n\nprint(safe_divide(10, 2))   # 5.0\nprint(safe_divide(10, 0))   # None\nprint(safe_divide(\"a\", 2))  # None\n```\n\n### Safe File Reading\n\n```python\ndef read_file(filename):\n    try:\n        with open(filename, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return \"File not found\"\n    except PermissionError:\n        return \"Permission denied\"\n```\n\n### Safe List Access\n\n```python\ndef get_item(lst, index, default=None):\n    try:\n        return lst[index]\n    except IndexError:\n        return default\n\nnumbers = [1, 2, 3]\nprint(get_item(numbers, 0))      # 1\nprint(get_item(numbers, 10))     # None\nprint(get_item(numbers, 10, -1)) # -1\n```\n\n### Safe Dictionary Access\n\n```python\ndef get_value(dictionary, key):\n    try:\n        return dictionary[key]\n    except KeyError:\n        return f\"Key '{key}' not found\"\n\ndata = {\"name\": \"Alice\", \"age\": 30}\nprint(get_value(data, \"name\"))   # Alice\nprint(get_value(data, \"email\"))  # Key 'email' not found\n```\n\n## Using Try-Except with User Input\n\n```python\ndef get_integer(prompt):\n    while True:\n        try:\n            return int(input(prompt))\n        except ValueError:\n            print(\"Please enter a valid integer!\")\n\n# This keeps asking until valid input is given\n# age = get_integer(\"Enter your age: \")\n```\n\n## Bare Except (Avoid This!)\n\n```python\n# BAD - catches everything, including system exits\ntry:\n    do_something()\nexcept:\n    pass  # Silently ignores all errors\n\n# BETTER - catch Exception at minimum\ntry:\n    do_something()\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n```\n\n## Why Avoid Bare Except?\n\n- Catches `KeyboardInterrupt` (Ctrl+C)\n- Catches `SystemExit`\n- Hides bugs and makes debugging hard\n- Makes code behavior unpredictable\n\n## The Pass Statement\n\nUse `pass` when you want to ignore an exception:\n\n```python\ndef optional_file_delete(filename):\n    try:\n        os.remove(filename)\n    except FileNotFoundError:\n        pass  # File doesn't exist, that's fine\n```\n\n## Best Practices\n\n1. **Catch specific exceptions** - Not bare except\n2. **Keep try blocks small** - Only wrap risky code\n3. **Don't silence errors** - At least log them\n4. **Handle at the right level** - Where you can take action",
  "code": "# Try and Except - Handling Errors Gracefully\n\n# Example 1: Basic try-except\nprint(\"=== Basic Try-Except ===\")\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n\n# Example 2: Catching exception details\nprint(\"\\n=== Exception Details ===\")\ntry:\n    numbers = [1, 2, 3]\n    print(numbers[10])\nexcept IndexError as e:\n    print(f\"Error type: {type(e).__name__}\")\n    print(f\"Error message: {e}\")\n\n# Example 3: Safe conversion function\nprint(\"\\n=== Safe Conversion ===\")\ndef safe_int(value, default=0):\n    try:\n        return int(value)\n    except (ValueError, TypeError):\n        return default\n\nprint(f\"safe_int('42'): {safe_int('42')}\")\nprint(f\"safe_int('abc'): {safe_int('abc')}\")\nprint(f\"safe_int(None, -1): {safe_int(None, -1)}\")\n\n# Example 4: Practical use case\nprint(\"\\n=== Calculator Example ===\")\ndef calculate(expression):\n    try:\n        # Warning: eval is dangerous with untrusted input!\n        return eval(expression)\n    except ZeroDivisionError:\n        return \"Error: Division by zero\"\n    except SyntaxError:\n        return \"Error: Invalid expression\"\n    except Exception as e:\n        return f\"Error: {e}\"\n\nprint(f\"10 + 5 = {calculate('10 + 5')}\")\nprint(f\"10 / 0 = {calculate('10 / 0')}\")\nprint(f\"10 + = {calculate('10 +')}\") "
}
