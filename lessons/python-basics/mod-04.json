{
  "id": "mod-04",
  "title": "Creating Modules",
  "category": "Modules & Packages",
  "number": 53,
  "duration": "8 min read",
  "content": "## Creating Modules\n\nAny Python file can be a module. Learning to create your own modules is essential for organizing code in larger projects.\n\n## Your First Module\n\nCreate a file called `mathtools.py`:\n\n```python\n# mathtools.py\n\"\"\"Math utility functions.\"\"\"\n\ndef add(a, b):\n    \"\"\"Return the sum of two numbers.\"\"\"\n    return a + b\n\ndef multiply(a, b):\n    \"\"\"Return the product of two numbers.\"\"\"\n    return a * b\n\ndef square(x):\n    \"\"\"Return x squared.\"\"\"\n    return x ** 2\n\nPI = 3.14159\n```\n\nNow use it in another file:\n\n```python\n# main.py\nimport mathtools\n\nprint(mathtools.add(5, 3))       # 8\nprint(mathtools.multiply(4, 7))  # 28\nprint(mathtools.PI)              # 3.14159\n```\n\n## Module with Classes\n\n```python\n# shapes.py\n\"\"\"Geometric shape classes.\"\"\"\n\nimport math\n\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return math.pi * self.radius ** 2\n    \n    def circumference(self):\n        return 2 * math.pi * self.radius\n\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n```\n\nUsing the shapes module:\n\n```python\nfrom shapes import Circle, Rectangle\n\ncircle = Circle(5)\nprint(f\"Circle area: {circle.area():.2f}\")\n\nrect = Rectangle(4, 6)\nprint(f\"Rectangle area: {rect.area()}\")\n```\n\n## The __name__ Variable\n\nEvery module has a `__name__` attribute:\n\n```python\n# mymodule.py\nprint(f\"__name__ is: {__name__}\")\n\ndef greet():\n    print(\"Hello from mymodule!\")\n```\n\n```python\n# When run directly:\npython mymodule.py\n# Output: __name__ is: __main__\n\n# When imported:\nimport mymodule\n# Output: __name__ is: mymodule\n```\n\n## The if __name__ == \"__main__\" Pattern\n\nThis pattern lets code run only when executed directly:\n\n```python\n# calculator.py\ndef add(a, b):\n    return a + b\n\ndef subtract(a, b):\n    return a - b\n\ndef multiply(a, b):\n    return a * b\n\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\n# This only runs when file is executed directly\nif __name__ == \"__main__\":\n    print(\"Calculator Module Demo\")\n    print(f\"5 + 3 = {add(5, 3)}\")\n    print(f\"10 - 4 = {subtract(10, 4)}\")\n    print(f\"6 * 7 = {multiply(6, 7)}\")\n    print(f\"15 / 3 = {divide(15, 3)}\")\n```\n\n## Module with Tests\n\n```python\n# stringutils.py\n\"\"\"String utility functions.\"\"\"\n\ndef reverse(s):\n    \"\"\"Reverse a string.\"\"\"\n    return s[::-1]\n\ndef is_palindrome(s):\n    \"\"\"Check if string is a palindrome.\"\"\"\n    clean = s.lower().replace(\" \", \"\")\n    return clean == clean[::-1]\n\ndef word_count(s):\n    \"\"\"Count words in a string.\"\"\"\n    return len(s.split())\n\n# Test when run directly\nif __name__ == \"__main__\":\n    # Test reverse\n    assert reverse(\"hello\") == \"olleh\"\n    print(\"reverse: PASSED\")\n    \n    # Test is_palindrome\n    assert is_palindrome(\"radar\") == True\n    assert is_palindrome(\"hello\") == False\n    assert is_palindrome(\"A man a plan a canal Panama\") == True\n    print(\"is_palindrome: PASSED\")\n    \n    # Test word_count\n    assert word_count(\"hello world\") == 2\n    print(\"word_count: PASSED\")\n    \n    print(\"\\nAll tests passed!\")\n```\n\n## Module Variables and Constants\n\n```python\n# config.py\n\"\"\"Application configuration.\"\"\"\n\n# Constants (UPPERCASE by convention)\nDEBUG = True\nVERSION = \"1.0.0\"\nMAX_CONNECTIONS = 100\nDATABASE_URL = \"localhost:5432\"\n\n# Default settings\nDEFAULT_TIMEOUT = 30\nDEFAULT_RETRIES = 3\n\n# Configuration dictionary\nSETTINGS = {\n    \"debug\": DEBUG,\n    \"version\": VERSION,\n    \"max_connections\": MAX_CONNECTIONS,\n}\n\ndef get_setting(key, default=None):\n    \"\"\"Get a setting value.\"\"\"\n    return SETTINGS.get(key, default)\n```\n\n## Private Module Members\n\nBy convention, names starting with underscore are private:\n\n```python\n# database.py\n\"\"\"Database module.\"\"\"\n\n# Private variable\n_connection = None\n\n# Private function\ndef _connect():\n    global _connection\n    _connection = \"Connected!\"  # Simplified\n    return _connection\n\n# Public function\ndef get_connection():\n    \"\"\"Get the database connection.\"\"\"\n    if _connection is None:\n        _connect()\n    return _connection\n\n# Public function\ndef query(sql):\n    \"\"\"Execute a query.\"\"\"\n    conn = get_connection()\n    return f\"Executing: {sql}\"\n```\n\n## Controlling Public API with __all__\n\n```python\n# api.py\n\"\"\"Public API module.\"\"\"\n\n__all__ = ['public_func', 'PublicClass']\n\ndef public_func():\n    \"\"\"This is part of the public API.\"\"\"\n    return \"Public!\"\n\ndef _private_func():\n    \"\"\"This is internal.\"\"\"\n    return \"Private!\"\n\ndef internal_helper():\n    \"\"\"Not in __all__, but still accessible.\"\"\"\n    return \"Helper\"\n\nclass PublicClass:\n    pass\n\n# from api import *  \n# Only imports: public_func, PublicClass\n```\n\n## Module Organization Best Practices\n\n```python\n# mymodule.py\n\"\"\"Module docstring - describe the module's purpose.\"\"\"\n\n# 1. Imports at the top\nimport os\nimport sys\nfrom datetime import datetime\n\n# 2. Constants\nVERSION = \"1.0.0\"\nDEFAULT_VALUE = 42\n\n# 3. Module-level variables\n_cache = {}\n\n# 4. Classes\nclass MyClass:\n    pass\n\n# 5. Functions\ndef my_function():\n    pass\n\n# 6. Main block at the end\nif __name__ == \"__main__\":\n    print(\"Running as script\")\n```\n\n## Practice Exercise\n\nCreate and test your own module!",
  "code": "# Creating and using modules\n# (Simulating module behavior in a single file)\n\n# === Simulating a 'utils' module ===\ndef reverse_string(s):\n    \"\"\"Reverse a string.\"\"\"\n    return s[::-1]\n\ndef is_even(n):\n    \"\"\"Check if number is even.\"\"\"\n    return n % 2 == 0\n\ndef factorial(n):\n    \"\"\"Calculate factorial of n.\"\"\"\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n\n# Module-level constant\nVERSION = \"1.0.0\"\n\n# === Using our 'module' functions ===\nprint(\"=== String Utils ===\")\nprint(f\"Reverse 'Python': {reverse_string('Python')}\")\n\nprint(\"\\n=== Number Utils ===\")\nfor i in range(5):\n    print(f\"{i} is even: {is_even(i)}\")\n\nprint(f\"\\n5! = {factorial(5)}\")\n\n# === Demonstrating __name__ ===\nprint(f\"\\n=== Module Info ===\")\nprint(f\"Module version: {VERSION}\")\nprint(f\"__name__ = {__name__}\")\n\n# This pattern only runs code when script is executed directly\nif __name__ == \"__main__\":\n    print(\"\\n=== Running as main script ===\")\n    print(\"This only runs when executed directly!\")\n    \n    # Simple tests\n    assert reverse_string(\"abc\") == \"cba\"\n    assert is_even(4) == True\n    assert factorial(5) == 120\n    print(\"All tests passed!\")"
}
