{
  "id": "oop-08",
  "title": "Static Methods",
  "category": "Object-Oriented Programming",
  "number": 65,
  "duration": "7 min read",
  "content": "## What are Static Methods?\n\nStatic methods are methods that belong to a class but don't access instance (`self`) or class (`cls`) data. They're like regular functions that happen to live inside a class.\n\n```python\nclass Math:\n    @staticmethod\n    def add(a, b):\n        return a + b\n\nresult = Math.add(5, 3)  # 8\n```\n\n## Defining Static Methods\n\nUse the `@staticmethod` decorator:\n\n```python\nclass Calculator:\n    @staticmethod\n    def add(x, y):\n        return x + y\n    \n    @staticmethod\n    def multiply(x, y):\n        return x * y\n    \n    @staticmethod\n    def is_even(n):\n        return n % 2 == 0\n\nprint(Calculator.add(10, 5))      # 15\nprint(Calculator.multiply(4, 3))  # 12\nprint(Calculator.is_even(7))      # False\n```\n\n## When to Use Static Methods\n\n### Utility Functions\n\n```python\nclass StringUtils:\n    @staticmethod\n    def is_palindrome(s):\n        s = s.lower().replace(' ', '')\n        return s == s[::-1]\n    \n    @staticmethod\n    def word_count(s):\n        return len(s.split())\n    \n    @staticmethod\n    def capitalize_words(s):\n        return ' '.join(word.capitalize() for word in s.split())\n\nprint(StringUtils.is_palindrome(\"Race Car\"))  # True\nprint(StringUtils.word_count(\"Hello World\"))  # 2\n```\n\n### Validation Functions\n\n```python\nclass Validator:\n    @staticmethod\n    def is_valid_email(email):\n        return '@' in email and '.' in email.split('@')[-1]\n    \n    @staticmethod\n    def is_valid_phone(phone):\n        digits = ''.join(c for c in phone if c.isdigit())\n        return len(digits) == 10\n    \n    @staticmethod\n    def is_strong_password(password):\n        has_upper = any(c.isupper() for c in password)\n        has_lower = any(c.islower() for c in password)\n        has_digit = any(c.isdigit() for c in password)\n        return len(password) >= 8 and has_upper and has_lower and has_digit\n\nprint(Validator.is_valid_email(\"user@example.com\"))  # True\nprint(Validator.is_strong_password(\"Abc12345\"))      # True\n```\n\n### Conversion Functions\n\n```python\nclass Temperature:\n    def __init__(self, celsius):\n        self.celsius = celsius\n    \n    @staticmethod\n    def celsius_to_fahrenheit(c):\n        return (c * 9/5) + 32\n    \n    @staticmethod\n    def fahrenheit_to_celsius(f):\n        return (f - 32) * 5/9\n    \n    @staticmethod\n    def celsius_to_kelvin(c):\n        return c + 273.15\n\nprint(Temperature.celsius_to_fahrenheit(100))  # 212.0\nprint(Temperature.fahrenheit_to_celsius(32))   # 0.0\n```\n\n## Static vs Class vs Instance Methods\n\n```python\nclass Comparison:\n    class_attr = \"I'm a class attribute\"\n    \n    def __init__(self, value):\n        self.value = value\n    \n    def instance_method(self):\n        # Can access self and class\n        return f\"Instance: {self.value}, Class: {self.class_attr}\"\n    \n    @classmethod\n    def class_method(cls):\n        # Can access class, not instance\n        return f\"Class: {cls.class_attr}\"\n    \n    @staticmethod\n    def static_method(x):\n        # Can't access self or cls\n        return f\"Static: {x}\"\n\nobj = Comparison(42)\nprint(obj.instance_method())    # Instance: 42, Class: I'm a class attribute\nprint(obj.class_method())       # Class: I'm a class attribute\nprint(obj.static_method(100))   # Static: 100\n```\n\n## Comparison Table\n\n| Feature | Instance Method | Class Method | Static Method |\n|---------|----------------|--------------|---------------|\n| Decorator | None | `@classmethod` | `@staticmethod` |\n| First param | `self` | `cls` | None |\n| Access instance | Yes | No | No |\n| Access class | Yes | Yes | No |\n| Call on class | No | Yes | Yes |\n| Call on instance | Yes | Yes | Yes |\n\n## Why Use Static Methods?\n\n1. **Organization**: Keep related functions together in a class\n2. **Clarity**: Signal that the method doesn't modify state\n3. **Namespace**: Avoid polluting the global namespace\n4. **Testing**: Easy to test in isolation\n\n```python\nclass FileUtils:\n    @staticmethod\n    def get_extension(filename):\n        return filename.split('.')[-1] if '.' in filename else ''\n    \n    @staticmethod\n    def is_image(filename):\n        extensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp']\n        return FileUtils.get_extension(filename).lower() in extensions\n\nprint(FileUtils.get_extension(\"photo.jpg\"))  # jpg\nprint(FileUtils.is_image(\"document.pdf\"))    # False\n```",
  "code": "# Static Methods - Practice\n\nclass MathUtils:\n    \"\"\"Collection of mathematical utility functions\"\"\"\n    \n    @staticmethod\n    def factorial(n):\n        if n < 0:\n            raise ValueError(\"Factorial not defined for negative numbers\")\n        if n <= 1:\n            return 1\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n    \n    @staticmethod\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    @staticmethod\n    def fibonacci(n):\n        \"\"\"Return first n Fibonacci numbers\"\"\"\n        if n <= 0:\n            return []\n        if n == 1:\n            return [0]\n        fib = [0, 1]\n        for _ in range(2, n):\n            fib.append(fib[-1] + fib[-2])\n        return fib\n    \n    @staticmethod\n    def gcd(a, b):\n        \"\"\"Greatest common divisor\"\"\"\n        while b:\n            a, b = b, a % b\n        return a\n    \n    @staticmethod\n    def lcm(a, b):\n        \"\"\"Least common multiple\"\"\"\n        return abs(a * b) // MathUtils.gcd(a, b)\n\n# Use static methods directly on the class\nprint(\"Factorial of 5:\", MathUtils.factorial(5))\nprint(\"Is 17 prime?\", MathUtils.is_prime(17))\nprint(\"First 10 Fibonacci:\", MathUtils.fibonacci(10))\nprint(\"GCD of 48 and 18:\", MathUtils.gcd(48, 18))\nprint(\"LCM of 12 and 18:\", MathUtils.lcm(12, 18))\n\n# Find prime numbers\nprimes = [n for n in range(2, 50) if MathUtils.is_prime(n)]\nprint(f\"\\nPrimes under 50: {primes}\")"
}
