{
  "id": "oop-11",
  "title": "Multiple Inheritance",
  "category": "Object-Oriented Programming",
  "number": 68,
  "duration": "9 min read",
  "content": "## What is Multiple Inheritance?\n\nMultiple inheritance allows a class to inherit from more than one parent class, combining their attributes and methods.\n\n```python\nclass Flyer:\n    def fly(self):\n        print(\"Flying!\")\n\nclass Swimmer:\n    def swim(self):\n        print(\"Swimming!\")\n\nclass Duck(Flyer, Swimmer):  # Inherits from both\n    def quack(self):\n        print(\"Quack!\")\n\nduck = Duck()\nduck.fly()    # Flying!\nduck.swim()   # Swimming!\nduck.quack()  # Quack!\n```\n\n## Syntax\n\n```python\nclass Child(Parent1, Parent2, Parent3):\n    pass\n```\n\n## Method Resolution Order (MRO)\n\nPython uses C3 linearization to determine which method to call when multiple parents have the same method:\n\n```python\nclass A:\n    def method(self):\n        print(\"A\")\n\nclass B(A):\n    def method(self):\n        print(\"B\")\n\nclass C(A):\n    def method(self):\n        print(\"C\")\n\nclass D(B, C):  # B comes before C\n    pass\n\nd = D()\nd.method()  # B (first in MRO after D)\n\n# View the MRO\nprint(D.__mro__)\n# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)\n```\n\n## The Diamond Problem\n\n```python\nclass A:\n    def __init__(self):\n        print(\"A init\")\n        self.a = \"A\"\n\nclass B(A):\n    def __init__(self):\n        print(\"B init\")\n        super().__init__()\n        self.b = \"B\"\n\nclass C(A):\n    def __init__(self):\n        print(\"C init\")\n        super().__init__()\n        self.c = \"C\"\n\nclass D(B, C):\n    def __init__(self):\n        print(\"D init\")\n        super().__init__()\n        self.d = \"D\"\n\nd = D()\n# Output:\n# D init\n# B init\n# C init\n# A init (only once!)\n\nprint(d.a, d.b, d.c, d.d)  # A B C D\n```\n\n## Using `super()` Correctly\n\n```python\nclass Logger:\n    def __init__(self):\n        self.logs = []\n    \n    def log(self, message):\n        self.logs.append(message)\n\nclass Serializable:\n    def to_dict(self):\n        return self.__dict__.copy()\n\nclass User(Logger, Serializable):\n    def __init__(self, name):\n        super().__init__()  # Calls Logger.__init__\n        self.name = name\n    \n    def greet(self):\n        self.log(f\"{self.name} said hello\")\n        print(f\"Hello, I'm {self.name}\")\n\nuser = User(\"Alice\")\nuser.greet()\nprint(user.logs)      # [\"Alice said hello\"]\nprint(user.to_dict()) # {'logs': [...], 'name': 'Alice'}\n```\n\n## Mixins\n\nMixins are classes designed to add functionality through multiple inheritance:\n\n```python\nclass JSONMixin:\n    def to_json(self):\n        import json\n        return json.dumps(self.__dict__)\n\nclass PrintableMixin:\n    def print_info(self):\n        for key, value in self.__dict__.items():\n            print(f\"{key}: {value}\")\n\nclass TimestampMixin:\n    def add_timestamp(self):\n        from datetime import datetime\n        self.created_at = datetime.now().isoformat()\n\nclass User(JSONMixin, PrintableMixin, TimestampMixin):\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n        self.add_timestamp()\n\nuser = User(\"Alice\", \"alice@example.com\")\nuser.print_info()\nprint(user.to_json())\n```\n\n## Best Practices\n\n| Practice | Description |\n|----------|-------------|\n| Use mixins | Small, focused classes that add specific functionality |\n| Avoid deep hierarchies | Keep inheritance trees shallow |\n| Prefer composition | Sometimes \"has-a\" is better than \"is-a\" |\n| Understand MRO | Know how Python resolves methods |\n| Use `super()` consistently | Ensures proper MRO traversal |\n\n## When to Use Multiple Inheritance\n\n**Good use cases:**\n- Mixins for reusable functionality\n- Interface-like abstract base classes\n- Combining orthogonal behaviors\n\n**Avoid when:**\n- Classes have conflicting methods\n- Inheritance hierarchy becomes confusing\n- Composition would be clearer\n\n```python\n# Composition alternative\nclass Engine:\n    def start(self):\n        print(\"Engine starting\")\n\nclass Car:\n    def __init__(self):\n        self.engine = Engine()  # Has-a relationship\n    \n    def start(self):\n        self.engine.start()\n```",
  "code": "# Multiple Inheritance - Practice\n\n# Define mixins\nclass SerializerMixin:\n    \"\"\"Adds serialization capabilities\"\"\"\n    \n    def to_dict(self):\n        return {k: v for k, v in self.__dict__.items() \n                if not k.startswith('_')}\n    \n    def to_json(self):\n        import json\n        return json.dumps(self.to_dict(), indent=2, default=str)\n\nclass ValidatorMixin:\n    \"\"\"Adds validation capabilities\"\"\"\n    \n    def validate(self):\n        errors = []\n        for attr, rules in getattr(self, '_validation_rules', {}).items():\n            value = getattr(self, attr, None)\n            if 'required' in rules and not value:\n                errors.append(f\"{attr} is required\")\n            if 'min_length' in rules and len(str(value)) < rules['min_length']:\n                errors.append(f\"{attr} must be at least {rules['min_length']} chars\")\n        return errors\n\nclass AuditMixin:\n    \"\"\"Adds audit tracking\"\"\"\n    \n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        from datetime import datetime\n        self._created_at = datetime.now()\n        self._modified_at = None\n    \n    def mark_modified(self):\n        from datetime import datetime\n        self._modified_at = datetime.now()\n    \n    def get_audit_info(self):\n        return {\n            'created': self._created_at,\n            'modified': self._modified_at\n        }\n\n# Base class\nclass BaseModel:\n    def __init__(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n# Combine everything\nclass User(AuditMixin, SerializerMixin, ValidatorMixin, BaseModel):\n    _validation_rules = {\n        'username': {'required': True, 'min_length': 3},\n        'email': {'required': True}\n    }\n    \n    def __init__(self, username, email, role='user'):\n        super().__init__(username=username, email=email, role=role)\n\n# Test the combined class\nprint(\"=== Creating User ===\")\nuser = User(\"alice\", \"alice@example.com\", \"admin\")\n\nprint(\"\\n=== Serialization (from SerializerMixin) ===\")\nprint(user.to_json())\n\nprint(\"\\n=== Validation (from ValidatorMixin) ===\")\nprint(\"Errors:\", user.validate())\n\nprint(\"\\n=== Audit Info (from AuditMixin) ===\")\nprint(user.get_audit_info())\n\nprint(\"\\n=== MRO ===\")\nfor cls in User.__mro__:\n    print(f\"  {cls.__name__}\")\n\n# Test validation with invalid data\nprint(\"\\n=== Invalid User ===\")\nbad_user = User(\"\", \"\")  # Empty values\nprint(\"Errors:\", bad_user.validate())"
}
