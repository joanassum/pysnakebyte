{
  "id": "err-05",
  "title": "Raising Exceptions",
  "category": "Error Handling",
  "number": 85,
  "duration": "7 min read",
  "content": "## Raising Exceptions\n\nYou can raise exceptions intentionally using the `raise` statement. This is essential for input validation, enforcing constraints, and signaling errors in your own code.\n\n## Basic Raise Syntax\n\n```python\nraise ValueError(\"Invalid input provided\")\n```\n\n## Raising Built-in Exceptions\n\n```python\n# ValueError - wrong value\ndef set_age(age):\n    if age < 0:\n        raise ValueError(\"Age cannot be negative\")\n    return age\n\n# TypeError - wrong type\ndef greet(name):\n    if not isinstance(name, str):\n        raise TypeError(\"Name must be a string\")\n    return f\"Hello, {name}!\"\n\n# KeyError - missing key\ndef get_config(settings, key):\n    if key not in settings:\n        raise KeyError(f\"Required setting '{key}' not found\")\n    return settings[key]\n```\n\n## Common Exceptions to Raise\n\n| Exception | When to Use |\n|-----------|-------------|\n| `ValueError` | Invalid value for the type |\n| `TypeError` | Wrong type passed |\n| `KeyError` | Missing dictionary key |\n| `RuntimeError` | General runtime error |\n| `NotImplementedError` | Abstract method not implemented |\n| `PermissionError` | Insufficient permissions |\n| `FileNotFoundError` | File doesn't exist |\n\n## Input Validation\n\n```python\ndef create_user(username, email, age):\n    # Validate username\n    if not username:\n        raise ValueError(\"Username cannot be empty\")\n    if len(username) < 3:\n        raise ValueError(\"Username must be at least 3 characters\")\n    \n    # Validate email\n    if not isinstance(email, str):\n        raise TypeError(\"Email must be a string\")\n    if \"@\" not in email:\n        raise ValueError(\"Invalid email format\")\n    \n    # Validate age\n    if not isinstance(age, int):\n        raise TypeError(\"Age must be an integer\")\n    if age < 0 or age > 150:\n        raise ValueError(\"Age must be between 0 and 150\")\n    \n    return {\"username\": username, \"email\": email, \"age\": age}\n```\n\n## Re-raising Exceptions\n\nUse bare `raise` to re-raise the current exception:\n\n```python\ndef process_data(data):\n    try:\n        result = parse(data)\n    except ValueError as e:\n        print(f\"Logging error: {e}\")\n        raise  # Re-raises the same exception\n```\n\n## Chaining Exceptions\n\nUse `from` to chain exceptions, showing the cause:\n\n```python\ndef load_config(filename):\n    try:\n        with open(filename) as f:\n            return json.load(f)\n    except FileNotFoundError as e:\n        raise RuntimeError(f\"Config file missing\") from e\n    except json.JSONDecodeError as e:\n        raise RuntimeError(f\"Invalid config format\") from e\n```\n\nOutput shows the chain:\n```\nRuntimeError: Config file missing\n  caused by: FileNotFoundError: [Errno 2] No such file...\n```\n\n## Suppressing Exception Context\n\nUse `from None` to hide the original exception:\n\n```python\ndef get_user(user_id):\n    try:\n        return database.find(user_id)\n    except DatabaseError:\n        raise ValueError(\"User not found\") from None\n```\n\n## Assertions vs Raising\n\n```python\n# Assertions - for debugging, can be disabled\nassert age >= 0, \"Age cannot be negative\"\n\n# Raise - for runtime validation, always active\nif age < 0:\n    raise ValueError(\"Age cannot be negative\")\n```\n\nUse `raise` for user input validation, `assert` for internal checks.\n\n## Guard Clauses Pattern\n\n```python\ndef calculate_discount(price, percentage):\n    # Guard clauses at the start\n    if price < 0:\n        raise ValueError(\"Price cannot be negative\")\n    if not 0 <= percentage <= 100:\n        raise ValueError(\"Percentage must be 0-100\")\n    \n    # Main logic (only reached if inputs are valid)\n    return price * (percentage / 100)\n```\n\n## Practical Examples\n\n### API Parameter Validation\n\n```python\ndef fetch_users(limit=10, offset=0):\n    if not isinstance(limit, int) or limit < 1:\n        raise ValueError(\"limit must be a positive integer\")\n    if not isinstance(offset, int) or offset < 0:\n        raise ValueError(\"offset must be a non-negative integer\")\n    if limit > 100:\n        raise ValueError(\"limit cannot exceed 100\")\n    \n    return database.get_users(limit=limit, offset=offset)\n```\n\n### State Validation\n\n```python\nclass Order:\n    def __init__(self):\n        self.status = \"pending\"\n        self.items = []\n    \n    def add_item(self, item):\n        if self.status != \"pending\":\n            raise RuntimeError(\"Cannot modify a processed order\")\n        self.items.append(item)\n    \n    def process(self):\n        if not self.items:\n            raise ValueError(\"Cannot process empty order\")\n        if self.status != \"pending\":\n            raise RuntimeError(\"Order already processed\")\n        self.status = \"processing\"\n```\n\n### Contract Programming\n\n```python\ndef divide(a, b):\n    \"\"\"Divide a by b.\n    \n    Preconditions:\n        - b != 0\n    \"\"\"\n    if b == 0:\n        raise ValueError(\"Divisor cannot be zero\")\n    return a / b\n```\n\n## Best Practices\n\n1. **Be specific** - Choose the right exception type\n2. **Be descriptive** - Include helpful error messages\n3. **Validate early** - Check inputs at function start\n4. **Document exceptions** - In docstrings, list what can be raised\n5. **Use from** - Chain exceptions to preserve context",
  "code": "# Raising Exceptions - Signaling Errors in Your Code\n\n# Example 1: Basic validation\nprint(\"=== Input Validation ===\")\n\ndef set_temperature(celsius):\n    if not isinstance(celsius, (int, float)):\n        raise TypeError(\"Temperature must be a number\")\n    if celsius < -273.15:\n        raise ValueError(\"Temperature below absolute zero!\")\n    return celsius\n\n# Test valid input\nprint(f\"Valid: {set_temperature(25)}\")\n\n# Test invalid inputs\nfor value in [\"hot\", -300, -273.15]:\n    try:\n        set_temperature(value)\n    except (TypeError, ValueError) as e:\n        print(f\"Invalid ({value}): {type(e).__name__}: {e}\")\n\n# Example 2: Guard clauses\nprint(\"\\n=== Guard Clauses ===\")\n\ndef create_rectangle(width, height):\n    # Guard clauses - validate at the start\n    if width <= 0:\n        raise ValueError(f\"Width must be positive, got {width}\")\n    if height <= 0:\n        raise ValueError(f\"Height must be positive, got {height}\")\n    \n    # Main logic\n    return {\n        'width': width,\n        'height': height,\n        'area': width * height,\n        'perimeter': 2 * (width + height)\n    }\n\nprint(create_rectangle(5, 3))\n\ntry:\n    create_rectangle(-5, 3)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# Example 3: Re-raising exceptions\nprint(\"\\n=== Re-raising Exceptions ===\")\n\ndef process_user_input(data):\n    try:\n        value = int(data)\n        return value * 2\n    except ValueError:\n        print(f\"Logging: Failed to process '{data}'\")\n        raise  # Re-raise the original exception\n\ntry:\n    process_user_input(\"abc\")\nexcept ValueError as e:\n    print(f\"Caught re-raised exception: {e}\")\n\n# Example 4: Exception chaining\nprint(\"\\n=== Exception Chaining ===\")\n\ndef parse_config(config_string):\n    try:\n        key, value = config_string.split('=')\n        return {key.strip(): value.strip()}\n    except ValueError as original:\n        raise ValueError(\n            f\"Invalid config format: '{config_string}'\"\n        ) from original\n\ntry:\n    parse_config(\"invalid-config\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n    if e.__cause__:\n        print(f\"Caused by: {e.__cause__}\")\n\n# Example 5: State validation\nprint(\"\\n=== State Validation ===\")\n\nclass BankAccount:\n    def __init__(self, balance=0):\n        if balance < 0:\n            raise ValueError(\"Initial balance cannot be negative\")\n        self.balance = balance\n        self.is_frozen = False\n    \n    def withdraw(self, amount):\n        if self.is_frozen:\n            raise RuntimeError(\"Account is frozen\")\n        if amount <= 0:\n            raise ValueError(\"Amount must be positive\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient funds\")\n        self.balance -= amount\n        return self.balance\n\naccount = BankAccount(100)\nprint(f\"Initial balance: {account.balance}\")\nprint(f\"After withdraw 30: {account.withdraw(30)}\")\n\ntry:\n    account.withdraw(100)\nexcept ValueError as e:\n    print(f\"Failed: {e}\")"
}
