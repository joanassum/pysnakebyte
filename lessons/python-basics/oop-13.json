{
  "id": "oop-13",
  "title": "Properties",
  "category": "Object-Oriented Programming",
  "number": 70,
  "duration": "8 min read",
  "content": "## What are Properties?\n\nProperties allow you to define methods that can be accessed like attributes. They provide a pythonic way to implement getters, setters, and deleters.\n\n```python\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n    \n    @property\n    def radius(self):\n        return self._radius\n\ncircle = Circle(5)\nprint(circle.radius)  # 5 (looks like attribute access)\n```\n\n## The `@property` Decorator\n\n### Getter\n\n```python\nclass Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius\n    \n    @property\n    def celsius(self):\n        \"\"\"Get temperature in Celsius\"\"\"\n        return self._celsius\n    \n    @property\n    def fahrenheit(self):\n        \"\"\"Get temperature in Fahrenheit (computed)\"\"\"\n        return (self._celsius * 9/5) + 32\n\ntemp = Temperature(25)\nprint(temp.celsius)     # 25\nprint(temp.fahrenheit)  # 77.0\n```\n\n### Setter\n\n```python\nclass Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius\n    \n    @property\n    def celsius(self):\n        return self._celsius\n    \n    @celsius.setter\n    def celsius(self, value):\n        if value < -273.15:\n            raise ValueError(\"Below absolute zero!\")\n        self._celsius = value\n\ntemp = Temperature(25)\ntemp.celsius = 100  # Uses setter\nprint(temp.celsius)  # 100\n\n# temp.celsius = -300  # Raises ValueError\n```\n\n### Deleter\n\n```python\nclass Person:\n    def __init__(self, name):\n        self._name = name\n    \n    @property\n    def name(self):\n        return self._name\n    \n    @name.setter\n    def name(self, value):\n        self._name = value\n    \n    @name.deleter\n    def name(self):\n        print(\"Deleting name\")\n        self._name = None\n\nperson = Person(\"Alice\")\ndel person.name  # Deleting name\nprint(person.name)  # None\n```\n\n## Computed Properties\n\nProperties can compute values on-the-fly:\n\n```python\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    @property\n    def area(self):\n        return self.width * self.height\n    \n    @property\n    def perimeter(self):\n        return 2 * (self.width + self.height)\n    \n    @property\n    def is_square(self):\n        return self.width == self.height\n\nrect = Rectangle(4, 5)\nprint(rect.area)       # 20\nprint(rect.perimeter)  # 18\nprint(rect.is_square)  # False\n\nrect.width = 5\nprint(rect.is_square)  # True\n```\n\n## Validation with Properties\n\n```python\nclass User:\n    def __init__(self, email, age):\n        self.email = email  # Uses setter\n        self.age = age      # Uses setter\n    \n    @property\n    def email(self):\n        return self._email\n    \n    @email.setter\n    def email(self, value):\n        if '@' not in value:\n            raise ValueError(\"Invalid email\")\n        self._email = value\n    \n    @property\n    def age(self):\n        return self._age\n    \n    @age.setter\n    def age(self, value):\n        if not 0 <= value <= 150:\n            raise ValueError(\"Invalid age\")\n        self._age = value\n\nuser = User(\"alice@example.com\", 25)\nprint(user.email)  # alice@example.com\n```\n\n## Read-Only Properties\n\n```python\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n    \n    @property\n    def radius(self):\n        return self._radius\n    \n    @property\n    def area(self):\n        return 3.14159 * self._radius ** 2\n\ncircle = Circle(5)\nprint(circle.area)  # 78.53975\n# circle.area = 100  # AttributeError: can't set attribute\n```\n\n## Property vs Method\n\n| Use Property | Use Method |\n|--------------|------------|\n| Simple attribute access | Takes additional arguments |\n| No/minimal computation | Expensive computation |\n| No side effects | Has side effects |\n| Accessing data | Performing action |\n\n```python\nclass Account:\n    def __init__(self, balance):\n        self._balance = balance\n    \n    @property\n    def balance(self):  # Property: simple access\n        return self._balance\n    \n    def transfer(self, amount, target):  # Method: action with args\n        self._balance -= amount\n        target._balance += amount\n```\n\n## Alternative Syntax\n\n```python\nclass Product:\n    def __init__(self, price):\n        self._price = price\n    \n    def get_price(self):\n        return self._price\n    \n    def set_price(self, value):\n        if value < 0:\n            raise ValueError(\"Price cannot be negative\")\n        self._price = value\n    \n    # Create property from methods\n    price = property(get_price, set_price)\n\nproduct = Product(99.99)\nprint(product.price)  # 99.99\nproduct.price = 79.99\n```",
  "code": "# Properties - Practice\n\nclass Product:\n    \"\"\"Product with validated properties\"\"\"\n    \n    def __init__(self, name, price, quantity=0):\n        self.name = name\n        self.price = price  # Uses setter\n        self.quantity = quantity  # Uses setter\n    \n    @property\n    def name(self):\n        return self._name\n    \n    @name.setter\n    def name(self, value):\n        if not value or not value.strip():\n            raise ValueError(\"Name cannot be empty\")\n        self._name = value.strip()\n    \n    @property\n    def price(self):\n        return self._price\n    \n    @price.setter\n    def price(self, value):\n        if value < 0:\n            raise ValueError(\"Price cannot be negative\")\n        self._price = round(value, 2)\n    \n    @property\n    def quantity(self):\n        return self._quantity\n    \n    @quantity.setter\n    def quantity(self, value):\n        if value < 0:\n            raise ValueError(\"Quantity cannot be negative\")\n        self._quantity = int(value)\n    \n    # Computed properties (read-only)\n    @property\n    def total_value(self):\n        \"\"\"Total value of inventory\"\"\"\n        return self._price * self._quantity\n    \n    @property\n    def in_stock(self):\n        \"\"\"Check if product is in stock\"\"\"\n        return self._quantity > 0\n    \n    @property\n    def stock_status(self):\n        \"\"\"Human-readable stock status\"\"\"\n        if self._quantity == 0:\n            return \"Out of Stock\"\n        elif self._quantity < 10:\n            return \"Low Stock\"\n        else:\n            return \"In Stock\"\n    \n    def __str__(self):\n        return f\"{self.name}: ${self.price} ({self.quantity} units)\"\n\n# Create products\nprint(\"=== Creating Products ===\")\nlaptop = Product(\"Gaming Laptop\", 1299.99, 15)\nkeyboard = Product(\"Mechanical Keyboard\", 89.50, 5)\nmouse = Product(\"Wireless Mouse\", 29.99, 0)\n\nproducts = [laptop, keyboard, mouse]\n\n# Display products\nprint(\"\\n=== Product Inventory ===\")\nfor p in products:\n    print(f\"{p}\")\n    print(f\"  Status: {p.stock_status}\")\n    print(f\"  In Stock: {p.in_stock}\")\n    print(f\"  Total Value: ${p.total_value:,.2f}\")\n    print()\n\n# Modify using properties\nprint(\"=== Updating Inventory ===\")\nkeyboard.quantity = 25\nkeyboard.price = 79.99\nprint(f\"Updated: {keyboard}\")\nprint(f\"New Status: {keyboard.stock_status}\")\n\n# Try invalid values\nprint(\"\\n=== Validation Tests ===\")\ntry:\n    laptop.price = -100\nexcept ValueError as e:\n    print(f\"Price error: {e}\")\n\ntry:\n    mouse.quantity = -5\nexcept ValueError as e:\n    print(f\"Quantity error: {e}\")\n\ntry:\n    laptop.name = \"  \"\nexcept ValueError as e:\n    print(f\"Name error: {e}\")"
}
