{
  "id": "func-10",
  "title": "Recursion",
  "category": "Functions",
  "number": 47,
  "duration": "9 min read",
  "content": "## What is Recursion?\n\n**Recursion** is when a function calls itself. It's a powerful technique for solving problems that can be broken down into smaller, similar subproblems.\n\n## Basic Structure\n\nEvery recursive function needs:\n1. **Base case** - condition to stop recursion\n2. **Recursive case** - function calls itself with modified input\n\n```python\ndef countdown(n):\n    # Base case\n    if n <= 0:\n        print(\"Blastoff!\")\n        return\n    \n    # Recursive case\n    print(n)\n    countdown(n - 1)\n\ncountdown(5)\n# 5, 4, 3, 2, 1, Blastoff!\n```\n\n## Classic Example: Factorial\n\nFactorial: n! = n × (n-1) × (n-2) × ... × 1\n\n```python\ndef factorial(n):\n    # Base case\n    if n <= 1:\n        return 1\n    \n    # Recursive case\n    return n * factorial(n - 1)\n\nprint(factorial(5))  # 120 (5 × 4 × 3 × 2 × 1)\n\n# How it works:\n# factorial(5)\n# = 5 * factorial(4)\n# = 5 * 4 * factorial(3)\n# = 5 * 4 * 3 * factorial(2)\n# = 5 * 4 * 3 * 2 * factorial(1)\n# = 5 * 4 * 3 * 2 * 1\n# = 120\n```\n\n## Fibonacci Sequence\n\n```python\ndef fibonacci(n):\n    # Base cases\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Recursive case\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nfor i in range(10):\n    print(fibonacci(i), end=\" \")\n# 0 1 1 2 3 5 8 13 21 34\n```\n\n## Sum of List\n\n```python\ndef sum_list(numbers):\n    # Base case: empty list\n    if len(numbers) == 0:\n        return 0\n    \n    # Recursive case: first element + sum of rest\n    return numbers[0] + sum_list(numbers[1:])\n\nprint(sum_list([1, 2, 3, 4, 5]))  # 15\n```\n\n## Reversing a String\n\n```python\ndef reverse_string(s):\n    # Base case\n    if len(s) <= 1:\n        return s\n    \n    # Recursive case\n    return s[-1] + reverse_string(s[:-1])\n\nprint(reverse_string(\"hello\"))  # olleh\n```\n\n## Counting Down Digits\n\n```python\ndef count_digits(n):\n    n = abs(n)  # Handle negative\n    \n    # Base case\n    if n < 10:\n        return 1\n    \n    # Recursive case\n    return 1 + count_digits(n // 10)\n\nprint(count_digits(12345))  # 5\n```\n\n## Binary Search (Recursive)\n\n```python\ndef binary_search(arr, target, low, high):\n    # Base case: not found\n    if low > high:\n        return -1\n    \n    mid = (low + high) // 2\n    \n    # Base case: found\n    if arr[mid] == target:\n        return mid\n    \n    # Recursive cases\n    if arr[mid] > target:\n        return binary_search(arr, target, low, mid - 1)\n    else:\n        return binary_search(arr, target, mid + 1, high)\n\nnumbers = [1, 3, 5, 7, 9, 11, 13]\nresult = binary_search(numbers, 7, 0, len(numbers) - 1)\nprint(f\"Found at index: {result}\")  # Found at index: 3\n```\n\n## Directory Tree (Conceptual)\n\n```python\ndef list_files(directory, indent=0):\n    # Would use os module in real code\n    prefix = \"  \" * indent\n    print(f\"{prefix}{directory.name}/\")\n    \n    for item in directory.contents:\n        if item.is_directory:\n            # Recursive call for subdirectory\n            list_files(item, indent + 1)\n        else:\n            print(f\"{prefix}  {item.name}\")\n```\n\n## Common Pitfalls\n\n### Missing Base Case\n\n```python\ndef infinite_recursion(n):\n    print(n)\n    infinite_recursion(n + 1)  # Never stops!\n    # Causes: RecursionError: maximum recursion depth exceeded\n```\n\n### Base Case Never Reached\n\n```python\ndef bad_factorial(n):\n    if n == 1:  # What if n is 0 or negative?\n        return 1\n    return n * bad_factorial(n - 1)\n\n# bad_factorial(0) -> infinite recursion!\n```\n\n## Recursion vs Iteration\n\n```python\n# Recursive factorial\ndef factorial_recursive(n):\n    if n <= 1:\n        return 1\n    return n * factorial_recursive(n - 1)\n\n# Iterative factorial\ndef factorial_iterative(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n```\n\n**When to use recursion:**\n- Tree/graph traversal\n- Problems with recursive structure\n- When code clarity is priority\n\n**When to use iteration:**\n- Performance is critical\n- Simple linear processing\n- Deep recursion would overflow stack\n\n## Tail Recursion (Optimization)\n\n```python\n# Regular recursion (creates stack frames)\ndef factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n\n# Tail recursion (last operation is the call)\ndef factorial_tail(n, accumulator=1):\n    if n <= 1:\n        return accumulator\n    return factorial_tail(n - 1, n * accumulator)\n\nprint(factorial_tail(5))  # 120\n```\n\nNote: Python doesn't optimize tail recursion, but it's still a good pattern.",
  "code": "# Recursion\n# Functions that call themselves\n\n# Basic countdown\ndef countdown(n):\n    if n <= 0:\n        print(\"Done!\")\n        return\n    print(n)\n    countdown(n - 1)\n\ncountdown(5)\n\n# Factorial: n! = n * (n-1) * ... * 1\ndef factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n\nprint(f\"5! = {factorial(5)}\")  # 120\n\n# Sum of list\ndef sum_recursive(numbers):\n    if len(numbers) == 0:\n        return 0\n    return numbers[0] + sum_recursive(numbers[1:])\n\nprint(sum_recursive([1, 2, 3, 4, 5]))  # 15\n\n# Exercise: Write a recursive function 'power(base, exp)'\n# that calculates base^exp without using ** operator\n# Hint: base^exp = base * base^(exp-1), base^0 = 1\n\n"
}
