{
  "id": "oop-12",
  "title": "Encapsulation",
  "category": "Object-Oriented Programming",
  "number": 69,
  "duration": "8 min read",
  "content": "## What is Encapsulation?\n\nEncapsulation is the bundling of data and methods that operate on that data within a single unit (class), while restricting direct access to some components. It protects internal state from unintended interference.\n\n```python\nclass BankAccount:\n    def __init__(self, balance):\n        self._balance = balance  # Protected\n    \n    def deposit(self, amount):\n        if amount > 0:\n            self._balance += amount\n    \n    def get_balance(self):\n        return self._balance\n```\n\n## Access Modifiers in Python\n\nPython uses naming conventions for access control:\n\n| Convention | Meaning | Example |\n|------------|---------|--------|\n| `name` | Public | `self.name` |\n| `_name` | Protected (internal use) | `self._name` |\n| `__name` | Private (name mangling) | `self.__name` |\n\n## Public Attributes\n\nAccessible from anywhere:\n\n```python\nclass Person:\n    def __init__(self, name):\n        self.name = name  # Public\n\nperson = Person(\"Alice\")\nprint(person.name)    # Alice\nperson.name = \"Bob\"   # Can modify directly\nprint(person.name)    # Bob\n```\n\n## Protected Attributes (Single Underscore)\n\nIndicates internal use, but still accessible:\n\n```python\nclass Employee:\n    def __init__(self, name, salary):\n        self.name = name\n        self._salary = salary  # Protected\n    \n    def give_raise(self, percent):\n        self._salary *= (1 + percent/100)\n\nemp = Employee(\"Alice\", 50000)\nprint(emp._salary)  # 50000 (accessible but discouraged)\nemp.give_raise(10)  # Preferred way to modify\n```\n\n## Private Attributes (Double Underscore)\n\nName mangling makes direct access harder:\n\n```python\nclass SecureAccount:\n    def __init__(self, pin):\n        self.__pin = pin  # Private\n    \n    def verify_pin(self, entered_pin):\n        return self.__pin == entered_pin\n\naccount = SecureAccount(\"1234\")\n# print(account.__pin)  # AttributeError!\nprint(account.verify_pin(\"1234\"))  # True\n\n# Name mangling: still accessible via _ClassName__attr\nprint(account._SecureAccount__pin)  # 1234 (not recommended)\n```\n\n## Getter and Setter Methods\n\n```python\nclass Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius\n    \n    def get_celsius(self):\n        return self._celsius\n    \n    def set_celsius(self, value):\n        if value < -273.15:\n            raise ValueError(\"Below absolute zero!\")\n        self._celsius = value\n    \n    def get_fahrenheit(self):\n        return (self._celsius * 9/5) + 32\n\ntemp = Temperature(25)\nprint(temp.get_celsius())     # 25\nprint(temp.get_fahrenheit())  # 77.0\n\ntemp.set_celsius(100)\nprint(temp.get_fahrenheit())  # 212.0\n```\n\n## Why Use Encapsulation?\n\n### 1. Data Validation\n\n```python\nclass User:\n    def __init__(self, age):\n        self._age = None\n        self.set_age(age)\n    \n    def set_age(self, age):\n        if not 0 <= age <= 150:\n            raise ValueError(\"Invalid age\")\n        self._age = age\n```\n\n### 2. Computed Properties\n\n```python\nclass Rectangle:\n    def __init__(self, width, height):\n        self._width = width\n        self._height = height\n    \n    def get_area(self):\n        return self._width * self._height\n```\n\n### 3. Hiding Implementation Details\n\n```python\nclass Stack:\n    def __init__(self):\n        self._items = []  # Implementation detail\n    \n    def push(self, item):\n        self._items.append(item)\n    \n    def pop(self):\n        if self._items:\n            return self._items.pop()\n        raise IndexError(\"Stack is empty\")\n    \n    def is_empty(self):\n        return len(self._items) == 0\n```\n\n### 4. Maintaining Invariants\n\n```python\nclass Counter:\n    def __init__(self):\n        self._count = 0  # Always non-negative\n    \n    def increment(self):\n        self._count += 1\n    \n    def decrement(self):\n        if self._count > 0:\n            self._count -= 1\n    \n    def get_count(self):\n        return self._count\n```\n\n## Encapsulation Benefits\n\n| Benefit | Description |\n|---------|-------------|\n| Data Protection | Prevent invalid modifications |\n| Flexibility | Change implementation without affecting users |\n| Maintainability | Easier to debug and modify |\n| Abstraction | Hide complexity from users |",
  "code": "# Encapsulation - Practice\n\nclass BankAccount:\n    \"\"\"A secure bank account with encapsulated data\"\"\"\n    \n    def __init__(self, account_holder, initial_balance=0):\n        self.account_holder = account_holder  # Public\n        self._balance = initial_balance       # Protected\n        self.__pin = None                     # Private\n        self._transaction_history = []        # Protected\n    \n    def set_pin(self, pin):\n        \"\"\"Set or change PIN\"\"\"\n        if len(str(pin)) != 4:\n            raise ValueError(\"PIN must be 4 digits\")\n        self.__pin = str(pin)\n        self._log_transaction(\"PIN set\")\n    \n    def verify_pin(self, pin):\n        \"\"\"Verify PIN for transactions\"\"\"\n        return self.__pin == str(pin)\n    \n    def deposit(self, amount):\n        \"\"\"Deposit money (no PIN needed)\"\"\"\n        if amount <= 0:\n            raise ValueError(\"Amount must be positive\")\n        self._balance += amount\n        self._log_transaction(f\"Deposit: +${amount}\")\n    \n    def withdraw(self, amount, pin):\n        \"\"\"Withdraw money (requires PIN)\"\"\"\n        if not self.verify_pin(pin):\n            self._log_transaction(\"Failed withdrawal: Invalid PIN\")\n            raise ValueError(\"Invalid PIN\")\n        if amount <= 0:\n            raise ValueError(\"Amount must be positive\")\n        if amount > self._balance:\n            raise ValueError(\"Insufficient funds\")\n        self._balance -= amount\n        self._log_transaction(f\"Withdrawal: -${amount}\")\n    \n    def get_balance(self, pin):\n        \"\"\"Check balance (requires PIN)\"\"\"\n        if not self.verify_pin(pin):\n            raise ValueError(\"Invalid PIN\")\n        return self._balance\n    \n    def _log_transaction(self, description):\n        \"\"\"Internal method to log transactions\"\"\"\n        from datetime import datetime\n        self._transaction_history.append({\n            'time': datetime.now().strftime(\"%H:%M:%S\"),\n            'description': description\n        })\n    \n    def get_statement(self, pin):\n        \"\"\"Get account statement (requires PIN)\"\"\"\n        if not self.verify_pin(pin):\n            raise ValueError(\"Invalid PIN\")\n        print(f\"\\nAccount Statement for {self.account_holder}\")\n        print(\"-\" * 40)\n        for t in self._transaction_history:\n            print(f\"  [{t['time']}] {t['description']}\")\n        print(\"-\" * 40)\n        print(f\"Current Balance: ${self._balance}\")\n\n# Use the encapsulated bank account\naccount = BankAccount(\"Alice Smith\", 1000)\n\n# Set PIN\naccount.set_pin(1234)\n\n# Deposit (no PIN needed)\naccount.deposit(500)\naccount.deposit(250)\n\n# Withdraw (PIN required)\naccount.withdraw(200, 1234)\n\n# Try wrong PIN\ntry:\n    account.withdraw(100, 9999)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# Check balance and get statement\nprint(f\"\\nBalance: ${account.get_balance(1234)}\")\naccount.get_statement(1234)\n\n# Direct access to private attribute fails\ntry:\n    print(account.__pin)\nexcept AttributeError:\n    print(\"\\nCannot access private __pin directly!\")"
}
