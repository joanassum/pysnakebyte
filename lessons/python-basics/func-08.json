{
  "id": "func-08",
  "title": "Global Variables",
  "category": "Functions",
  "number": 45,
  "duration": "7 min read",
  "content": "## The global Keyword\n\nTo modify a global variable inside a function, use the `global` keyword:\n\n```python\ncount = 0\n\ndef increment():\n    global count\n    count += 1\n\nprint(count)  # 0\nincrement()\nprint(count)  # 1\nincrement()\nprint(count)  # 2\n```\n\n## Why global is Needed\n\nWithout `global`, Python creates a local variable:\n\n```python\nvalue = 100\n\ndef without_global():\n    value = 200  # Creates NEW local variable\n    print(f\"Inside: {value}\")\n\ndef with_global():\n    global value\n    value = 200  # Modifies global variable\n    print(f\"Inside: {value}\")\n\nwithout_global()\nprint(f\"After without_global: {value}\")  # 100 (unchanged)\n\nwith_global()\nprint(f\"After with_global: {value}\")     # 200 (changed)\n```\n\n## Reading vs Modifying\n\nYou only need `global` to **modify** a global variable:\n\n```python\nPI = 3.14159\n\ndef calculate_area(radius):\n    # Reading global - no 'global' needed\n    return PI * radius ** 2\n\nprint(calculate_area(5))  # 78.53975\n```\n\n## The nonlocal Keyword\n\nFor nested functions, use `nonlocal` to modify enclosing scope variables:\n\n```python\ndef counter():\n    count = 0\n    \n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    \n    return increment\n\nmy_counter = counter()\nprint(my_counter())  # 1\nprint(my_counter())  # 2\nprint(my_counter())  # 3\n```\n\n## When to Use Global Variables\n\n### Good Uses\n\n```python\n# Constants (by convention, use UPPERCASE)\nMAX_RETRIES = 3\nDEFAULT_TIMEOUT = 30\nAPI_BASE_URL = \"https://api.example.com\"\n\n# Configuration\nDEBUG = True\nVERBOSE = False\n```\n\n### Avoid Overusing\n\n```python\n# BAD: Global state makes code hard to follow\nresult = 0\n\ndef add(a, b):\n    global result\n    result = a + b\n\ndef multiply(a, b):\n    global result\n    result = a * b\n\nadd(5, 3)\nprint(result)  # 8 - but which function set it?\n\n# GOOD: Return values instead\ndef add(a, b):\n    return a + b\n\ndef multiply(a, b):\n    return a * b\n\nresult = add(5, 3)\nprint(result)  # 8 - clear where it came from\n```\n\n## Global State Patterns\n\n### Counter Pattern\n\n```python\n_call_count = 0\n\ndef tracked_function():\n    global _call_count\n    _call_count += 1\n    print(f\"Called {_call_count} times\")\n\ntracked_function()  # Called 1 times\ntracked_function()  # Called 2 times\n```\n\n### Cache Pattern\n\n```python\n_cache = {}\n\ndef expensive_calculation(n):\n    global _cache\n    if n in _cache:\n        print(\"From cache\")\n        return _cache[n]\n    \n    print(\"Calculating...\")\n    result = n ** 2  # Pretend this is slow\n    _cache[n] = result\n    return result\n\nprint(expensive_calculation(5))  # Calculating... 25\nprint(expensive_calculation(5))  # From cache 25\n```\n\n## Better Alternatives\n\n### Use Parameters and Return Values\n\n```python\n# Instead of global\ndef process_data(data, config):\n    return modified_data\n```\n\n### Use Classes\n\n```python\nclass Counter:\n    def __init__(self):\n        self.count = 0\n    \n    def increment(self):\n        self.count += 1\n        return self.count\n\ncounter = Counter()\nprint(counter.increment())  # 1\nprint(counter.increment())  # 2\n```\n\n### Use Closures\n\n```python\ndef make_counter():\n    count = 0\n    \n    def counter():\n        nonlocal count\n        count += 1\n        return count\n    \n    return counter\n\nmy_counter = make_counter()\nprint(my_counter())  # 1\nprint(my_counter())  # 2\n```\n\n## Best Practices\n\n1. **Avoid mutable global state** - it makes debugging hard\n2. **Use UPPERCASE for constants** - signals \"don't modify\"\n3. **Prefer parameters and return values** - explicit data flow\n4. **Consider classes or closures** - encapsulate state properly\n5. **Document global dependencies** - when you must use globals",
  "code": "# Global Variables\n# Modifying global state from functions\n\n# Global variable\nscore = 0\n\ndef add_points(points):\n    global score  # Declare we're using the global\n    score += points\n    print(f\"Score: {score}\")\n\nadd_points(10)\nadd_points(25)\nadd_points(15)\n\nprint(f\"Final score: {score}\")\n\n# nonlocal for nested functions\ndef create_counter():\n    count = 0\n    \n    def increment():\n        nonlocal count  # Access enclosing scope\n        count += 1\n        return count\n    \n    return increment\n\ncounter = create_counter()\nprint(counter())  # 1\nprint(counter())  # 2\nprint(counter())  # 3\n\n# Exercise: Create a simple game score tracker\n# - Global variable 'high_score' starting at 0\n# - Function 'check_score(score)' that:\n#   - Updates high_score if score is higher\n#   - Prints appropriate message\n\n"
}
