{
  "id": "err-06",
  "title": "Custom Exceptions",
  "category": "Error Handling",
  "number": 86,
  "duration": "7 min read",
  "content": "## Custom Exceptions\n\nCreating your own exception classes allows you to define domain-specific errors that make your code more readable and your error handling more precise.\n\n## Basic Custom Exception\n\nInherit from `Exception` (or a more specific built-in exception):\n\n```python\nclass ValidationError(Exception):\n    \"\"\"Raised when data validation fails.\"\"\"\n    pass\n\n# Usage\nraise ValidationError(\"Email format is invalid\")\n```\n\n## Why Custom Exceptions?\n\n1. **Clarity** - `raise InsufficientFundsError()` is clearer than `raise ValueError(\"insufficient funds\")`\n2. **Precision** - Catch specific errors without catching unrelated ones\n3. **Organization** - Group related errors into hierarchies\n4. **Information** - Add custom attributes with error details\n\n## Exception with Custom Attributes\n\n```python\nclass ValidationError(Exception):\n    def __init__(self, field, message):\n        self.field = field\n        self.message = message\n        super().__init__(f\"{field}: {message}\")\n\n# Usage\ntry:\n    raise ValidationError(\"email\", \"Invalid format\")\nexcept ValidationError as e:\n    print(f\"Field: {e.field}\")\n    print(f\"Message: {e.message}\")\n```\n\n## Exception Hierarchies\n\nCreate a hierarchy for related exceptions:\n\n```python\n# Base exception for your application\nclass AppError(Exception):\n    \"\"\"Base exception for all application errors.\"\"\"\n    pass\n\n# Specific exceptions inherit from base\nclass DatabaseError(AppError):\n    \"\"\"Database-related errors.\"\"\"\n    pass\n\nclass ConnectionError(DatabaseError):\n    \"\"\"Database connection failed.\"\"\"\n    pass\n\nclass QueryError(DatabaseError):\n    \"\"\"Query execution failed.\"\"\"\n    pass\n\nclass AuthenticationError(AppError):\n    \"\"\"Authentication failed.\"\"\"\n    pass\n```\n\nNow you can catch at different levels:\n\n```python\ntry:\n    connect_to_database()\nexcept ConnectionError:\n    # Handle connection specifically\n    retry_connection()\nexcept DatabaseError:\n    # Handle any database error\n    use_fallback()\nexcept AppError:\n    # Handle any application error\n    show_error_page()\n```\n\n## Real-World Examples\n\n### E-Commerce Exception Hierarchy\n\n```python\nclass ShopError(Exception):\n    \"\"\"Base exception for the shop.\"\"\"\n    pass\n\nclass ProductError(ShopError):\n    \"\"\"Product-related errors.\"\"\"\n    pass\n\nclass ProductNotFoundError(ProductError):\n    def __init__(self, product_id):\n        self.product_id = product_id\n        super().__init__(f\"Product {product_id} not found\")\n\nclass OutOfStockError(ProductError):\n    def __init__(self, product_id, requested, available):\n        self.product_id = product_id\n        self.requested = requested\n        self.available = available\n        super().__init__(\n            f\"Product {product_id}: requested {requested}, \"\n            f\"only {available} available\"\n        )\n\nclass PaymentError(ShopError):\n    \"\"\"Payment-related errors.\"\"\"\n    pass\n\nclass InsufficientFundsError(PaymentError):\n    def __init__(self, required, available):\n        self.required = required\n        self.available = available\n        super().__init__(\n            f\"Insufficient funds: need {required}, have {available}\"\n        )\n\nclass PaymentDeclinedError(PaymentError):\n    def __init__(self, reason):\n        self.reason = reason\n        super().__init__(f\"Payment declined: {reason}\")\n```\n\n### API Exception with Status Codes\n\n```python\nclass APIError(Exception):\n    \"\"\"Base API exception with status code.\"\"\"\n    status_code = 500\n    \n    def __init__(self, message=None):\n        self.message = message or self.__class__.__doc__\n        super().__init__(self.message)\n    \n    def to_dict(self):\n        return {\n            'error': self.__class__.__name__,\n            'message': self.message,\n            'status_code': self.status_code\n        }\n\nclass NotFoundError(APIError):\n    \"\"\"Resource not found.\"\"\"\n    status_code = 404\n\nclass UnauthorizedError(APIError):\n    \"\"\"Authentication required.\"\"\"\n    status_code = 401\n\nclass ForbiddenError(APIError):\n    \"\"\"Access denied.\"\"\"\n    status_code = 403\n\nclass BadRequestError(APIError):\n    \"\"\"Invalid request.\"\"\"\n    status_code = 400\n```\n\n### Validation Errors with Details\n\n```python\nclass ValidationError(Exception):\n    def __init__(self, errors=None):\n        self.errors = errors or {}\n        message = \"; \".join(\n            f\"{field}: {msg}\" \n            for field, msg in self.errors.items()\n        )\n        super().__init__(message)\n    \n    def add_error(self, field, message):\n        self.errors[field] = message\n\ndef validate_user(data):\n    errors = {}\n    \n    if not data.get('username'):\n        errors['username'] = 'Required'\n    elif len(data['username']) < 3:\n        errors['username'] = 'Must be at least 3 characters'\n    \n    if not data.get('email'):\n        errors['email'] = 'Required'\n    elif '@' not in data['email']:\n        errors['email'] = 'Invalid format'\n    \n    if errors:\n        raise ValidationError(errors)\n    \n    return True\n```\n\n## Best Practices\n\n### 1. Always Inherit from Exception\n\n```python\n# Good\nclass MyError(Exception):\n    pass\n\n# Bad - inheriting from BaseException\nclass MyError(BaseException):  # Don't do this!\n    pass\n```\n\n### 2. Use Meaningful Names\n\n```python\n# Good - descriptive names ending in Error\nclass InsufficientFundsError(Exception): pass\nclass InvalidTokenError(Exception): pass\n\n# Bad - vague or poorly named\nclass Error1(Exception): pass\nclass MyException(Exception): pass\n```\n\n### 3. Provide Useful Information\n\n```python\nclass FileProcessingError(Exception):\n    def __init__(self, filename, line_number, reason):\n        self.filename = filename\n        self.line_number = line_number\n        self.reason = reason\n        super().__init__(\n            f\"{filename}:{line_number}: {reason}\"\n        )\n```\n\n### 4. Document Your Exceptions\n\n```python\nclass RateLimitError(Exception):\n    \"\"\"Raised when API rate limit is exceeded.\n    \n    Attributes:\n        limit: The rate limit that was exceeded\n        reset_time: When the limit resets (Unix timestamp)\n    \"\"\"\n    def __init__(self, limit, reset_time):\n        self.limit = limit\n        self.reset_time = reset_time\n        super().__init__(f\"Rate limit ({limit}) exceeded\")\n```",
  "code": "# Custom Exceptions - Domain-Specific Error Handling\n\n# Example 1: Basic custom exception\nprint(\"=== Basic Custom Exception ===\")\n\nclass ValidationError(Exception):\n    \"\"\"Raised when validation fails.\"\"\"\n    pass\n\ndef validate_username(username):\n    if len(username) < 3:\n        raise ValidationError(\"Username must be at least 3 characters\")\n    if not username.isalnum():\n        raise ValidationError(\"Username must be alphanumeric\")\n    return True\n\nfor name in [\"ab\", \"user@name\", \"validuser\"]:\n    try:\n        validate_username(name)\n        print(f\"'{name}' is valid\")\n    except ValidationError as e:\n        print(f\"'{name}' invalid: {e}\")\n\n# Example 2: Exception with custom attributes\nprint(\"\\n=== Exception with Attributes ===\")\n\nclass InsufficientFundsError(Exception):\n    def __init__(self, required, available):\n        self.required = required\n        self.available = available\n        self.shortfall = required - available\n        super().__init__(\n            f\"Need ${required}, have ${available} (short ${self.shortfall})\"\n        )\n\nclass BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n    \n    def withdraw(self, amount):\n        if amount > self.balance:\n            raise InsufficientFundsError(amount, self.balance)\n        self.balance -= amount\n        return self.balance\n\naccount = BankAccount(100)\ntry:\n    account.withdraw(150)\nexcept InsufficientFundsError as e:\n    print(f\"Error: {e}\")\n    print(f\"You need ${e.shortfall} more\")\n\n# Example 3: Exception hierarchy\nprint(\"\\n=== Exception Hierarchy ===\")\n\nclass ShopError(Exception):\n    \"\"\"Base exception for shop.\"\"\"\n    pass\n\nclass ProductError(ShopError):\n    \"\"\"Product-related error.\"\"\"\n    pass\n\nclass OutOfStockError(ProductError):\n    def __init__(self, product, available=0):\n        self.product = product\n        self.available = available\n        super().__init__(f\"'{product}' out of stock ({available} left)\")\n\nclass PaymentError(ShopError):\n    \"\"\"Payment-related error.\"\"\"\n    pass\n\ndef process_order(product, quantity):\n    inventory = {\"apple\": 5, \"banana\": 0}\n    \n    if product not in inventory:\n        raise ProductError(f\"Unknown product: {product}\")\n    if inventory[product] < quantity:\n        raise OutOfStockError(product, inventory[product])\n    \n    return f\"Ordered {quantity} {product}(s)\"\n\n# Test the hierarchy\nfor order in [(\"apple\", 3), (\"banana\", 1), (\"orange\", 2)]:\n    try:\n        result = process_order(*order)\n        print(f\"Success: {result}\")\n    except OutOfStockError as e:\n        print(f\"Stock issue: {e}\")\n    except ProductError as e:\n        print(f\"Product issue: {e}\")\n    except ShopError as e:\n        print(f\"Shop error: {e}\")\n\n# Example 4: API-style exceptions\nprint(\"\\n=== API-Style Exceptions ===\")\n\nclass APIError(Exception):\n    status_code = 500\n    \n    def to_response(self):\n        return {\n            \"error\": self.__class__.__name__,\n            \"message\": str(self),\n            \"status\": self.status_code\n        }\n\nclass NotFoundError(APIError):\n    status_code = 404\n\nclass BadRequestError(APIError):\n    status_code = 400\n\ndef get_user(user_id):\n    users = {1: \"Alice\", 2: \"Bob\"}\n    if user_id not in users:\n        raise NotFoundError(f\"User {user_id} not found\")\n    return users[user_id]\n\nfor uid in [1, 99]:\n    try:\n        print(f\"Found: {get_user(uid)}\")\n    except APIError as e:\n        print(f\"API Error: {e.to_response()}\")"
}
