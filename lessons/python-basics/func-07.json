{
  "id": "func-07",
  "title": "Variable Scope",
  "category": "Functions",
  "number": 44,
  "duration": "8 min read",
  "content": "## What is Scope?\n\n**Scope** determines where a variable can be accessed in your code. Variables created inside functions behave differently from those created outside.\n\n## Local Scope\n\nVariables created inside a function are **local** to that function:\n\n```python\ndef my_function():\n    x = 10  # Local variable\n    print(f\"Inside function: x = {x}\")\n\nmy_function()\n# print(x)  # NameError: name 'x' is not defined\n```\n\nLocal variables:\n- Are created when the function runs\n- Are destroyed when the function ends\n- Cannot be accessed outside the function\n\n## Global Scope\n\nVariables created outside functions are **global**:\n\n```python\ny = 20  # Global variable\n\ndef my_function():\n    print(f\"Inside function: y = {y}\")  # Can read global\n\nmy_function()\nprint(f\"Outside function: y = {y}\")  # Still accessible\n```\n\n## The LEGB Rule\n\nPython looks for variables in this order:\n\n1. **L**ocal - Inside the current function\n2. **E**nclosing - Inside enclosing functions (nested functions)\n3. **G**lobal - At the module level\n4. **B**uilt-in - Python's built-in names\n\n```python\nx = \"global\"\n\ndef outer():\n    x = \"enclosing\"\n    \n    def inner():\n        x = \"local\"\n        print(f\"inner: {x}\")  # local\n    \n    inner()\n    print(f\"outer: {x}\")  # enclosing\n\nouter()\nprint(f\"global: {x}\")  # global\n```\n\n## Shadowing Variables\n\nLocal variables can **shadow** (hide) global variables:\n\n```python\nname = \"Alice\"  # Global\n\ndef greet():\n    name = \"Bob\"  # Local - shadows global\n    print(f\"Hello, {name}\")\n\ngreet()           # Hello, Bob\nprint(name)       # Alice (global unchanged)\n```\n\n## Parameters are Local\n\nFunction parameters are local variables:\n\n```python\ndef double(x):\n    x = x * 2  # x is local\n    return x\n\nvalue = 5\nresult = double(value)\nprint(result)  # 10\nprint(value)   # 5 (unchanged)\n```\n\n## Modifying Mutable Objects\n\nMutable objects (lists, dicts) can be modified even without `global`:\n\n```python\nmy_list = [1, 2, 3]\n\ndef add_item(item):\n    my_list.append(item)  # Modifies the list\n\nadd_item(4)\nprint(my_list)  # [1, 2, 3, 4]\n\n# But reassignment creates a local variable\ndef replace_list():\n    my_list = [10, 20]  # Creates LOCAL my_list\n    print(f\"Inside: {my_list}\")\n\nreplace_list()         # Inside: [10, 20]\nprint(my_list)         # [1, 2, 3, 4] (global unchanged)\n```\n\n## Nested Function Scope\n\n```python\ndef outer():\n    outer_var = \"I'm from outer\"\n    \n    def inner():\n        inner_var = \"I'm from inner\"\n        print(outer_var)  # Can access outer's variables\n        print(inner_var)\n    \n    inner()\n    # print(inner_var)  # Error: not accessible here\n\nouter()\n```\n\n## Common Scope Mistakes\n\n### Mistake 1: Referencing Before Assignment\n\n```python\ncount = 0\n\ndef increment():\n    # count = count + 1  # UnboundLocalError!\n    # Python sees 'count =' and assumes it's local\n    # But we're trying to read it before assigning\n    pass\n```\n\n### Mistake 2: Assuming Modification Works\n\n```python\ntotal = 100\n\ndef add_to_total(value):\n    total = total + value  # Error! Same reason\n\n# Fix: use 'global' keyword (next lesson)\n```\n\n## Practical Example\n\n```python\n# Game with proper scoping\nplayer_name = \"Hero\"  # Global - rarely changes\n\ndef create_player():\n    health = 100      # Local\n    inventory = []    # Local\n    \n    def take_damage(amount):\n        nonlocal health  # Access enclosing scope\n        health -= amount\n        return health\n    \n    def add_item(item):\n        inventory.append(item)\n    \n    return take_damage, add_item, lambda: (health, inventory)\n\ndamage, pickup, status = create_player()\ndamage(20)\npickup(\"Sword\")\nprint(status())  # (80, ['Sword'])\n```\n\n## Best Practices\n\n1. **Minimize global variables** - pass data as parameters\n2. **Use descriptive local names** - avoid shadowing globals accidentally\n3. **Keep functions small** - easier to track scope\n4. **Return values instead of modifying globals**",
  "code": "# Variable Scope\n# Where variables can be accessed\n\n# Global variable\nmessage = \"Hello from global\"\n\ndef show_message():\n    # Can read global variables\n    print(message)\n\nshow_message()\n\ndef create_local():\n    # Local variable - only exists inside function\n    local_var = \"I'm local\"\n    print(local_var)\n\ncreate_local()\n# print(local_var)  # This would cause an error!\n\n# Shadowing - local hides global\nname = \"Alice\"\n\ndef greet():\n    name = \"Bob\"  # This is a different, local 'name'\n    print(f\"Inside: {name}\")\n\ngreet()\nprint(f\"Outside: {name}\")  # Global is unchanged\n\n# Exercise: Predict what this prints, then run it\nx = \"global\"\n\ndef func1():\n    x = \"func1 local\"\n    print(f\"func1: {x}\")\n\ndef func2():\n    print(f\"func2: {x}\")\n\nfunc1()\nfunc2()\nprint(f\"main: {x}\")\n"
}
