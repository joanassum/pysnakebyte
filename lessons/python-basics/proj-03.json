{
  "id": "proj-03",
  "title": "Building a CLI Tool",
  "category": "Bonus: Real-World Projects",
  "number": 103,
  "duration": "15 min read",
  "content": "## Project Overview\n\nBuild a professional command-line interface (CLI) tool using Python. You'll learn to create commands, handle arguments, and build user-friendly terminal applications.\n\n## Learning Objectives\n\n- Parse command-line arguments with argparse\n- Create subcommands for different functionalities\n- Handle user input and provide helpful output\n- Structure a CLI application professionally\n\n## Step 1: Basic Argument Parsing\n\nStart with Python's built-in argparse module:\n\n```python\nimport argparse\n\ndef create_parser():\n    \"\"\"Create the argument parser.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog='mytool',\n        description='A powerful command-line tool',\n        epilog='Example: mytool process --input file.txt'\n    )\n    \n    parser.add_argument(\n        '-v', '--version',\n        action='version',\n        version='%(prog)s 1.0.0'\n    )\n    \n    parser.add_argument(\n        '--verbose',\n        action='store_true',\n        help='Enable verbose output'\n    )\n    \n    return parser\n\nif __name__ == '__main__':\n    parser = create_parser()\n    args = parser.parse_args()\n```\n\n## Step 2: Adding Positional and Optional Arguments\n\nLearn different types of arguments:\n\n```python\ndef create_parser():\n    parser = argparse.ArgumentParser(description='File processor tool')\n    \n    # Positional argument (required)\n    parser.add_argument(\n        'filename',\n        help='The file to process'\n    )\n    \n    # Optional argument with value\n    parser.add_argument(\n        '-o', '--output',\n        default='output.txt',\n        help='Output file name (default: output.txt)'\n    )\n    \n    # Optional argument with choices\n    parser.add_argument(\n        '-f', '--format',\n        choices=['json', 'csv', 'xml'],\n        default='json',\n        help='Output format'\n    )\n    \n    # Numeric argument\n    parser.add_argument(\n        '-n', '--count',\n        type=int,\n        default=10,\n        help='Number of items to process'\n    )\n    \n    # Multiple values\n    parser.add_argument(\n        '--tags',\n        nargs='+',\n        help='Tags to apply'\n    )\n    \n    return parser\n```\n\n## Step 3: Implementing Subcommands\n\nCreate a CLI with multiple commands like git:\n\n```python\nimport argparse\nimport sys\n\ndef cmd_init(args):\n    \"\"\"Initialize a new project.\"\"\"\n    print(f\"Initializing project: {args.name}\")\n    if args.template:\n        print(f\"Using template: {args.template}\")\n\ndef cmd_build(args):\n    \"\"\"Build the project.\"\"\"\n    print(f\"Building project...\")\n    if args.release:\n        print(\"Building in release mode\")\n    else:\n        print(\"Building in debug mode\")\n\ndef cmd_deploy(args):\n    \"\"\"Deploy the project.\"\"\"\n    print(f\"Deploying to: {args.environment}\")\n\ndef create_parser():\n    parser = argparse.ArgumentParser(prog='devtool')\n    subparsers = parser.add_subparsers(dest='command', help='Available commands')\n    \n    # init command\n    init_parser = subparsers.add_parser('init', help='Initialize a project')\n    init_parser.add_argument('name', help='Project name')\n    init_parser.add_argument('-t', '--template', help='Project template')\n    init_parser.set_defaults(func=cmd_init)\n    \n    # build command\n    build_parser = subparsers.add_parser('build', help='Build the project')\n    build_parser.add_argument('-r', '--release', action='store_true')\n    build_parser.set_defaults(func=cmd_build)\n    \n    # deploy command\n    deploy_parser = subparsers.add_parser('deploy', help='Deploy the project')\n    deploy_parser.add_argument('environment', choices=['dev', 'staging', 'prod'])\n    deploy_parser.set_defaults(func=cmd_deploy)\n    \n    return parser\n\ndef main():\n    parser = create_parser()\n    args = parser.parse_args()\n    \n    if args.command is None:\n        parser.print_help()\n        sys.exit(1)\n    \n    args.func(args)\n\nif __name__ == '__main__':\n    main()\n```\n\n## Step 4: Adding Color and Formatting\n\nMake your CLI visually appealing:\n\n```python\nclass Colors:\n    \"\"\"ANSI color codes for terminal output.\"\"\"\n    RED = '\\033[91m'\n    GREEN = '\\033[92m'\n    YELLOW = '\\033[93m'\n    BLUE = '\\033[94m'\n    MAGENTA = '\\033[95m'\n    CYAN = '\\033[96m'\n    WHITE = '\\033[97m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n    END = '\\033[0m'\n\ndef print_success(message):\n    print(f\"{Colors.GREEN}[SUCCESS]{Colors.END} {message}\")\n\ndef print_error(message):\n    print(f\"{Colors.RED}[ERROR]{Colors.END} {message}\")\n\ndef print_warning(message):\n    print(f\"{Colors.YELLOW}[WARNING]{Colors.END} {message}\")\n\ndef print_info(message):\n    print(f\"{Colors.BLUE}[INFO]{Colors.END} {message}\")\n```\n\n## Step 5: Progress Indicators\n\nShow progress for long-running operations:\n\n```python\nimport sys\nimport time\n\ndef progress_bar(current, total, width=50):\n    \"\"\"Display a progress bar.\"\"\"\n    percent = current / total\n    filled = int(width * percent)\n    bar = '=' * filled + '-' * (width - filled)\n    sys.stdout.write(f'\\r[{bar}] {percent:.1%}')\n    sys.stdout.flush()\n    if current == total:\n        print()  # New line when complete\n\ndef spinner(message, duration=3):\n    \"\"\"Display a spinner animation.\"\"\"\n    chars = '|/-\\\\'\n    end_time = time.time() + duration\n    i = 0\n    while time.time() < end_time:\n        sys.stdout.write(f'\\r{chars[i % len(chars)]} {message}')\n        sys.stdout.flush()\n        time.sleep(0.1)\n        i += 1\n    print(f'\\r  {message} - Done!')\n```\n\n## Step 6: Configuration Files\n\nLoad settings from configuration files:\n\n```python\nimport json\nimport os\nfrom pathlib import Path\n\nDEFAULT_CONFIG = {\n    'output_dir': './output',\n    'verbose': False,\n    'format': 'json'\n}\n\ndef get_config_path():\n    \"\"\"Get the configuration file path.\"\"\"\n    return Path.home() / '.mytool' / 'config.json'\n\ndef load_config():\n    \"\"\"Load configuration from file.\"\"\"\n    config_path = get_config_path()\n    if config_path.exists():\n        with open(config_path) as f:\n            return {**DEFAULT_CONFIG, **json.load(f)}\n    return DEFAULT_CONFIG.copy()\n\ndef save_config(config):\n    \"\"\"Save configuration to file.\"\"\"\n    config_path = get_config_path()\n    config_path.parent.mkdir(parents=True, exist_ok=True)\n    with open(config_path, 'w') as f:\n        json.dump(config, f, indent=2)\n```\n\n## Step 7: Interactive Prompts\n\nGet input from users interactively:\n\n```python\ndef confirm(message, default=False):\n    \"\"\"Ask for yes/no confirmation.\"\"\"\n    suffix = ' [Y/n]: ' if default else ' [y/N]: '\n    response = input(message + suffix).strip().lower()\n    if not response:\n        return default\n    return response in ('y', 'yes')\n\ndef prompt(message, default=None):\n    \"\"\"Prompt for text input.\"\"\"\n    if default:\n        response = input(f\"{message} [{default}]: \").strip()\n        return response or default\n    return input(f\"{message}: \").strip()\n\ndef choose(message, options):\n    \"\"\"Let user choose from options.\"\"\"\n    print(message)\n    for i, option in enumerate(options, 1):\n        print(f\"  {i}. {option}\")\n    \n    while True:\n        try:\n            choice = int(input(\"Enter number: \"))\n            if 1 <= choice <= len(options):\n                return options[choice - 1]\n        except ValueError:\n            pass\n        print(\"Invalid choice. Try again.\")\n```\n\n## Challenge Extensions\n\n1. **Auto-completion**: Add shell auto-completion support\n2. **Plugin System**: Allow users to add custom commands\n3. **Update Checker**: Check for new versions on startup\n4. **Shell Mode**: Interactive REPL for your tool",
  "code": "#!/usr/bin/env python3\n\"\"\"Task Manager CLI - A command-line task management tool.\"\"\"\n\nimport argparse\nimport json\nimport sys\nfrom pathlib import Path\nfrom datetime import datetime\n\n# ANSI Colors\nclass Colors:\n    RED = '\\033[91m'\n    GREEN = '\\033[92m'\n    YELLOW = '\\033[93m'\n    BLUE = '\\033[94m'\n    BOLD = '\\033[1m'\n    END = '\\033[0m'\n\ndef success(msg): print(f\"{Colors.GREEN}[OK]{Colors.END} {msg}\")\ndef error(msg): print(f\"{Colors.RED}[ERROR]{Colors.END} {msg}\")\ndef info(msg): print(f\"{Colors.BLUE}[INFO]{Colors.END} {msg}\")\n\n# Task Storage\nTASKS_FILE = Path.home() / '.tasks.json'\n\ndef load_tasks():\n    \"\"\"Load tasks from file.\"\"\"\n    if TASKS_FILE.exists():\n        return json.loads(TASKS_FILE.read_text())\n    return []\n\ndef save_tasks(tasks):\n    \"\"\"Save tasks to file.\"\"\"\n    TASKS_FILE.write_text(json.dumps(tasks, indent=2))\n\n# Commands\ndef cmd_add(args):\n    \"\"\"Add a new task.\"\"\"\n    tasks = load_tasks()\n    task = {\n        'id': len(tasks) + 1,\n        'title': args.title,\n        'priority': args.priority,\n        'done': False,\n        'created': datetime.now().isoformat()\n    }\n    tasks.append(task)\n    save_tasks(tasks)\n    success(f\"Added task #{task['id']}: {args.title}\")\n\ndef cmd_list(args):\n    \"\"\"List all tasks.\"\"\"\n    tasks = load_tasks()\n    if not tasks:\n        info(\"No tasks found. Add one with 'tasks add <title>'\")\n        return\n    \n    print(f\"\\n{Colors.BOLD}Your Tasks:{Colors.END}\\n\")\n    for task in tasks:\n        status = f\"{Colors.GREEN}[done]{Colors.END}\" if task['done'] else f\"{Colors.YELLOW}[todo]{Colors.END}\"\n        priority = task.get('priority', 'medium')\n        print(f\"  {task['id']}. {status} {task['title']} ({priority})\")\n    print()\n\ndef cmd_done(args):\n    \"\"\"Mark a task as done.\"\"\"\n    tasks = load_tasks()\n    for task in tasks:\n        if task['id'] == args.task_id:\n            task['done'] = True\n            save_tasks(tasks)\n            success(f\"Completed: {task['title']}\")\n            return\n    error(f\"Task #{args.task_id} not found\")\n\ndef cmd_remove(args):\n    \"\"\"Remove a task.\"\"\"\n    tasks = load_tasks()\n    for i, task in enumerate(tasks):\n        if task['id'] == args.task_id:\n            removed = tasks.pop(i)\n            save_tasks(tasks)\n            success(f\"Removed: {removed['title']}\")\n            return\n    error(f\"Task #{args.task_id} not found\")\n\ndef cmd_clear(args):\n    \"\"\"Clear all completed tasks.\"\"\"\n    tasks = load_tasks()\n    remaining = [t for t in tasks if not t['done']]\n    cleared = len(tasks) - len(remaining)\n    save_tasks(remaining)\n    success(f\"Cleared {cleared} completed tasks\")\n\n# Main Parser\ndef create_parser():\n    parser = argparse.ArgumentParser(\n        prog='tasks',\n        description='A simple command-line task manager'\n    )\n    parser.add_argument('-v', '--version', action='version', version='tasks 1.0.0')\n    \n    subparsers = parser.add_subparsers(dest='command', help='Commands')\n    \n    # add command\n    add_p = subparsers.add_parser('add', help='Add a new task')\n    add_p.add_argument('title', help='Task title')\n    add_p.add_argument('-p', '--priority', choices=['low', 'medium', 'high'], default='medium')\n    add_p.set_defaults(func=cmd_add)\n    \n    # list command\n    list_p = subparsers.add_parser('list', help='List all tasks')\n    list_p.set_defaults(func=cmd_list)\n    \n    # done command\n    done_p = subparsers.add_parser('done', help='Mark task as done')\n    done_p.add_argument('task_id', type=int, help='Task ID')\n    done_p.set_defaults(func=cmd_done)\n    \n    # remove command\n    rm_p = subparsers.add_parser('remove', help='Remove a task')\n    rm_p.add_argument('task_id', type=int, help='Task ID')\n    rm_p.set_defaults(func=cmd_remove)\n    \n    # clear command\n    clear_p = subparsers.add_parser('clear', help='Clear completed tasks')\n    clear_p.set_defaults(func=cmd_clear)\n    \n    return parser\n\ndef main():\n    parser = create_parser()\n    args = parser.parse_args()\n    \n    if args.command is None:\n        parser.print_help()\n        sys.exit(0)\n    \n    args.func(args)\n\nif __name__ == '__main__':\n    main()"
}
