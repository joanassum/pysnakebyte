{
  "id": "oop-15",
  "title": "Abstract Classes",
  "category": "Object-Oriented Programming",
  "number": 72,
  "duration": "8 min read",
  "content": "## What are Abstract Classes?\n\nAbstract classes are classes that cannot be instantiated directly. They serve as blueprints for other classes, defining methods that must be implemented by subclasses.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):  # Abstract class\n    @abstractmethod\n    def area(self):\n        pass\n\n# shape = Shape()  # TypeError: Can't instantiate abstract class\n```\n\n## Creating Abstract Classes\n\nUse the `ABC` class and `@abstractmethod` decorator from the `abc` module:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    def __init__(self, name):\n        self.name = name\n    \n    @abstractmethod\n    def speak(self):\n        \"\"\"All animals must implement speak\"\"\"\n        pass\n    \n    @abstractmethod\n    def move(self):\n        \"\"\"All animals must implement move\"\"\"\n        pass\n    \n    def sleep(self):  # Concrete method (not abstract)\n        print(f\"{self.name} is sleeping\")\n```\n\n## Implementing Abstract Classes\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):  # Must implement abstract method\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):  # Must implement abstract method\n        return \"Meow!\"\n\ndog = Dog()\ncat = Cat()\nprint(dog.speak())  # Woof!\nprint(cat.speak())  # Meow!\n```\n\n## Abstract Properties\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n    @property\n    @abstractmethod\n    def max_speed(self):\n        pass\n    \n    @property\n    @abstractmethod\n    def fuel_type(self):\n        pass\n\nclass Car(Vehicle):\n    @property\n    def max_speed(self):\n        return 200\n    \n    @property\n    def fuel_type(self):\n        return \"Gasoline\"\n\ncar = Car()\nprint(f\"Max speed: {car.max_speed} km/h\")\nprint(f\"Fuel: {car.fuel_type}\")\n```\n\n## Mixing Abstract and Concrete Methods\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Database(ABC):\n    def __init__(self, connection_string):\n        self.connection_string = connection_string\n    \n    @abstractmethod\n    def connect(self):\n        \"\"\"Subclass must implement\"\"\"\n        pass\n    \n    @abstractmethod\n    def execute(self, query):\n        \"\"\"Subclass must implement\"\"\"\n        pass\n    \n    def close(self):  # Concrete method\n        print(\"Closing connection\")\n    \n    def log(self, message):  # Concrete method\n        print(f\"[DB] {message}\")\n\nclass PostgreSQL(Database):\n    def connect(self):\n        self.log(f\"Connecting to PostgreSQL...\")\n        return True\n    \n    def execute(self, query):\n        self.log(f\"Executing: {query}\")\n        return []\n\ndb = PostgreSQL(\"postgresql://localhost/mydb\")\ndb.connect()\ndb.execute(\"SELECT * FROM users\")\ndb.close()\n```\n\n## Why Use Abstract Classes?\n\n| Benefit | Description |\n|---------|-------------|\n| Contract | Ensures subclasses implement required methods |\n| Polymorphism | Treat all subclasses uniformly |\n| Documentation | Clearly defines interface |\n| Early Error Detection | Fails at instantiation, not runtime |\n\n## Abstract Class vs Interface\n\n```python\nfrom abc import ABC, abstractmethod\n\n# Interface-like (all abstract)\nclass Drawable(ABC):\n    @abstractmethod\n    def draw(self):\n        pass\n\n# Abstract class (mix of abstract and concrete)\nclass Shape(ABC):\n    def __init__(self, color):\n        self.color = color\n    \n    @abstractmethod\n    def area(self):\n        pass\n    \n    def describe(self):  # Concrete\n        return f\"A {self.color} shape\"\n```\n\n## Multiple Inheritance with ABCs\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Flyable(ABC):\n    @abstractmethod\n    def fly(self):\n        pass\n\nclass Swimmable(ABC):\n    @abstractmethod\n    def swim(self):\n        pass\n\nclass Duck(Flyable, Swimmable):\n    def fly(self):\n        print(\"Duck flying\")\n    \n    def swim(self):\n        print(\"Duck swimming\")\n\nduck = Duck()\nduck.fly()\nduck.swim()\n```\n\n## Calling Abstract Method from Subclass\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Logger(ABC):\n    @abstractmethod\n    def log(self, message):\n        \"\"\"Base implementation\"\"\"\n        print(f\"[LOG] {message}\")\n\nclass FileLogger(Logger):\n    def log(self, message):\n        super().log(message)  # Call abstract method\n        print(f\"Writing to file: {message}\")\n\nlogger = FileLogger()\nlogger.log(\"Hello\")\n# [LOG] Hello\n# Writing to file: Hello\n```",
  "code": "# Abstract Classes - Practice\n\nfrom abc import ABC, abstractmethod\n\nclass PaymentProcessor(ABC):\n    \"\"\"Abstract base class for payment processing\"\"\"\n    \n    def __init__(self, merchant_id):\n        self.merchant_id = merchant_id\n        self.transactions = []\n    \n    @abstractmethod\n    def process_payment(self, amount):\n        \"\"\"Process a payment - must be implemented\"\"\"\n        pass\n    \n    @abstractmethod\n    def refund(self, transaction_id):\n        \"\"\"Refund a payment - must be implemented\"\"\"\n        pass\n    \n    @property\n    @abstractmethod\n    def provider_name(self):\n        \"\"\"Return provider name - must be implemented\"\"\"\n        pass\n    \n    # Concrete methods\n    def log_transaction(self, type_, amount, status):\n        import random\n        trans_id = f\"TXN{random.randint(10000, 99999)}\"\n        self.transactions.append({\n            'id': trans_id,\n            'type': type_,\n            'amount': amount,\n            'status': status\n        })\n        return trans_id\n    \n    def get_total_processed(self):\n        return sum(t['amount'] for t in self.transactions \n                   if t['status'] == 'success' and t['type'] == 'payment')\n\nclass StripeProcessor(PaymentProcessor):\n    \"\"\"Stripe implementation\"\"\"\n    \n    @property\n    def provider_name(self):\n        return \"Stripe\"\n    \n    def process_payment(self, amount):\n        print(f\"[Stripe] Processing ${amount:.2f}...\")\n        trans_id = self.log_transaction('payment', amount, 'success')\n        print(f\"[Stripe] Payment successful! ID: {trans_id}\")\n        return trans_id\n    \n    def refund(self, transaction_id):\n        for t in self.transactions:\n            if t['id'] == transaction_id:\n                print(f\"[Stripe] Refunding {transaction_id}...\")\n                self.log_transaction('refund', t['amount'], 'success')\n                return True\n        return False\n\nclass PayPalProcessor(PaymentProcessor):\n    \"\"\"PayPal implementation\"\"\"\n    \n    @property\n    def provider_name(self):\n        return \"PayPal\"\n    \n    def process_payment(self, amount):\n        print(f\"[PayPal] Connecting to PayPal API...\")\n        print(f\"[PayPal] Processing ${amount:.2f}...\")\n        trans_id = self.log_transaction('payment', amount, 'success')\n        print(f\"[PayPal] Payment complete! ID: {trans_id}\")\n        return trans_id\n    \n    def refund(self, transaction_id):\n        for t in self.transactions:\n            if t['id'] == transaction_id:\n                print(f\"[PayPal] Initiating refund for {transaction_id}...\")\n                self.log_transaction('refund', t['amount'], 'success')\n                return True\n        return False\n\n# Polymorphic function - works with any PaymentProcessor\ndef checkout(processor: PaymentProcessor, amount: float):\n    print(f\"\\nUsing {processor.provider_name}\")\n    return processor.process_payment(amount)\n\n# Try to instantiate abstract class\nprint(\"=== Trying to instantiate abstract class ===\")\ntry:\n    p = PaymentProcessor(\"M001\")\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n\n# Use concrete implementations\nprint(\"\\n=== Processing Payments ===\")\nstripe = StripeProcessor(\"M001\")\npaypal = PayPalProcessor(\"M002\")\n\ntxn1 = checkout(stripe, 99.99)\ntxn2 = checkout(stripe, 49.99)\ntxn3 = checkout(paypal, 199.99)\n\nprint(f\"\\n=== Summary ===\")\nprint(f\"Stripe total: ${stripe.get_total_processed():.2f}\")\nprint(f\"PayPal total: ${paypal.get_total_processed():.2f}\")\n\nprint(f\"\\n=== Refund ===\")\nstripe.refund(txn1)"
}
