{
  "id": "oop-10",
  "title": "Method Overriding",
  "category": "Object-Oriented Programming",
  "number": 67,
  "duration": "8 min read",
  "content": "## What is Method Overriding?\n\nMethod overriding occurs when a child class provides a specific implementation for a method that is already defined in its parent class.\n\n```python\nclass Animal:\n    def speak(self):\n        return \"Some sound\"\n\nclass Dog(Animal):\n    def speak(self):  # Overrides parent method\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):  # Overrides parent method\n        return \"Meow!\"\n\ndog = Dog()\ncat = Cat()\nprint(dog.speak())  # Woof!\nprint(cat.speak())  # Meow!\n```\n\n## Why Override Methods?\n\n1. **Customize behavior** for specific subclasses\n2. **Extend functionality** while keeping the interface\n3. **Implement polymorphism** - same method name, different behavior\n\n## Basic Method Overriding\n\n```python\nclass Shape:\n    def area(self):\n        return 0\n    \n    def describe(self):\n        return \"I am a shape\"\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):  # Override\n        return self.width * self.height\n    \n    def describe(self):  # Override\n        return f\"Rectangle: {self.width}x{self.height}\"\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):  # Override\n        return 3.14159 * self.radius ** 2\n    \n    def describe(self):  # Override\n        return f\"Circle with radius {self.radius}\"\n\nshapes = [Rectangle(4, 5), Circle(3)]\nfor shape in shapes:\n    print(f\"{shape.describe()}, Area: {shape.area():.2f}\")\n```\n\n## Using `super()` in Overridden Methods\n\nCall the parent method while adding extra functionality:\n\n```python\nclass Vehicle:\n    def __init__(self, brand):\n        self.brand = brand\n    \n    def start(self):\n        print(f\"{self.brand} is starting...\")\n\nclass ElectricCar(Vehicle):\n    def __init__(self, brand, battery_level):\n        super().__init__(brand)\n        self.battery_level = battery_level\n    \n    def start(self):  # Override with extension\n        if self.battery_level > 10:\n            super().start()  # Call parent method\n            print(\"Electric motor engaged!\")\n        else:\n            print(\"Battery too low to start\")\n\ncar = ElectricCar(\"Tesla\", 85)\ncar.start()\n# Tesla is starting...\n# Electric motor engaged!\n```\n\n## Overriding `__init__`\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nclass Employee(Person):\n    def __init__(self, name, age, employee_id, department):\n        super().__init__(name, age)  # Call parent __init__\n        self.employee_id = employee_id\n        self.department = department\n\nemp = Employee(\"Alice\", 30, \"E123\", \"Engineering\")\nprint(f\"{emp.name}, {emp.department}\")  # Alice, Engineering\n```\n\n## Overriding with Different Signatures\n\n```python\nclass Notification:\n    def send(self, message):\n        print(f\"Notification: {message}\")\n\nclass EmailNotification(Notification):\n    def send(self, message, subject=\"No Subject\"):  # Extended signature\n        print(f\"Email - Subject: {subject}\")\n        super().send(message)\n\nclass SMSNotification(Notification):\n    def send(self, message, urgent=False):  # Different extension\n        prefix = \"URGENT: \" if urgent else \"\"\n        super().send(prefix + message)\n\nemail = EmailNotification()\nemail.send(\"Hello!\", subject=\"Greeting\")\n\nsms = SMSNotification()\nsms.send(\"Call me\", urgent=True)\n```\n\n## Polymorphism Through Overriding\n\n```python\nclass PaymentProcessor:\n    def process(self, amount):\n        raise NotImplementedError(\"Subclass must implement\")\n\nclass CreditCardProcessor(PaymentProcessor):\n    def process(self, amount):\n        print(f\"Processing ${amount} via credit card\")\n        return True\n\nclass PayPalProcessor(PaymentProcessor):\n    def process(self, amount):\n        print(f\"Processing ${amount} via PayPal\")\n        return True\n\nclass CryptoProcessor(PaymentProcessor):\n    def process(self, amount):\n        print(f\"Processing ${amount} via cryptocurrency\")\n        return True\n\n# Polymorphic usage\ndef checkout(processor, amount):\n    return processor.process(amount)\n\nprocessors = [\n    CreditCardProcessor(),\n    PayPalProcessor(),\n    CryptoProcessor()\n]\n\nfor p in processors:\n    checkout(p, 100)  # Same interface, different behavior\n```\n\n## Best Practices\n\n| Practice | Description |\n|----------|-------------|\n| Keep same interface | Override methods should accept compatible parameters |\n| Use `super()` | Call parent method when extending functionality |\n| Document changes | Explain how behavior differs from parent |\n| LSP | Substituting child for parent should not break code |",
  "code": "# Method Overriding - Practice\n\nclass Logger:\n    \"\"\"Base logger class\"\"\"\n    \n    def __init__(self, name):\n        self.name = name\n    \n    def log(self, message):\n        print(f\"[{self.name}] {message}\")\n    \n    def error(self, message):\n        self.log(f\"ERROR: {message}\")\n    \n    def warning(self, message):\n        self.log(f\"WARNING: {message}\")\n\nclass TimestampLogger(Logger):\n    \"\"\"Logger that adds timestamps\"\"\"\n    \n    def log(self, message):\n        from datetime import datetime\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        super().log(f\"{timestamp} - {message}\")\n\nclass FileLogger(Logger):\n    \"\"\"Logger that tracks messages for file writing\"\"\"\n    \n    def __init__(self, name, filename):\n        super().__init__(name)\n        self.filename = filename\n        self.messages = []  # Store messages\n    \n    def log(self, message):\n        super().log(message)  # Print to console\n        self.messages.append(message)  # Store for file\n    \n    def save(self):\n        print(f\"\\n--- Would save {len(self.messages)} messages to {self.filename} ---\")\n        for msg in self.messages:\n            print(f\"  {msg}\")\n\nclass ColorLogger(Logger):\n    \"\"\"Logger with level-based formatting\"\"\"\n    \n    def error(self, message):\n        # Override to add emphasis\n        print(f\"[{self.name}] *** ERROR *** {message} ***\")\n    \n    def warning(self, message):\n        # Override to add emphasis\n        print(f\"[{self.name}] >> WARNING: {message} <<\")\n\n# Test different loggers\nprint(\"=== Basic Logger ===\")\nbasic = Logger(\"App\")\nbasic.log(\"Starting application\")\nbasic.error(\"Something went wrong\")\n\nprint(\"\\n=== Timestamp Logger ===\")\nts_logger = TimestampLogger(\"App\")\nts_logger.log(\"Starting application\")\nts_logger.error(\"Something went wrong\")  # Uses overridden log()\n\nprint(\"\\n=== File Logger ===\")\nfile_logger = FileLogger(\"App\", \"app.log\")\nfile_logger.log(\"Starting\")\nfile_logger.warning(\"Low memory\")\nfile_logger.error(\"Crash!\")\nfile_logger.save()\n\nprint(\"\\n=== Color Logger ===\")\ncolor = ColorLogger(\"App\")\ncolor.log(\"Normal message\")\ncolor.warning(\"Watch out!\")\ncolor.error(\"Critical failure!\")"
}
