{
  "id": "func-12",
  "title": "Function Best Practices",
  "category": "Functions",
  "number": 49,
  "duration": "8 min read",
  "content": "## Writing Clean Functions\n\nWell-written functions make code easier to read, test, maintain, and reuse. Follow these best practices to write better functions.\n\n## 1. Do One Thing\n\nEach function should have a single, clear purpose:\n\n```python\n# BAD: Does too many things\ndef process_user(user_data):\n    # Validates data\n    # Creates user\n    # Sends email\n    # Logs event\n    pass\n\n# GOOD: Single responsibility\ndef validate_user_data(user_data):\n    pass\n\ndef create_user(validated_data):\n    pass\n\ndef send_welcome_email(user):\n    pass\n\ndef log_user_creation(user):\n    pass\n```\n\n## 2. Use Descriptive Names\n\nNames should describe what the function does:\n\n```python\n# BAD: Unclear names\ndef process(d):\n    pass\n\ndef do_stuff(x, y):\n    pass\n\n# GOOD: Descriptive names\ndef calculate_total_price(items):\n    pass\n\ndef send_password_reset_email(user_email):\n    pass\n\ndef is_valid_credit_card(card_number):\n    pass\n```\n\n### Naming Conventions\n\n- Use verbs for actions: `get_`, `set_`, `calculate_`, `create_`, `send_`\n- Use `is_`, `has_`, `can_` for boolean returns\n- Be specific: `get_user_by_id()` not `get_user()`\n\n## 3. Keep Functions Short\n\nAim for functions that fit on one screen (20-30 lines max):\n\n```python\n# If a function is too long, extract smaller functions\ndef generate_report(data):\n    header = create_header(data)\n    body = create_body(data)\n    footer = create_footer(data)\n    return combine_sections(header, body, footer)\n```\n\n## 4. Limit Parameters\n\nToo many parameters is a code smell:\n\n```python\n# BAD: Too many parameters\ndef create_user(first_name, last_name, email, phone, \n                address, city, state, zip_code, country):\n    pass\n\n# GOOD: Group related data\ndef create_user(personal_info, contact_info, address):\n    pass\n\n# Or use a class/dataclass\nfrom dataclasses import dataclass\n\n@dataclass\nclass UserData:\n    name: str\n    email: str\n    address: str\n\ndef create_user(user_data: UserData):\n    pass\n```\n\n## 5. Avoid Side Effects\n\nFunctions should be predictable:\n\n```python\n# BAD: Hidden side effect\nuser_count = 0\n\ndef create_user(name):\n    global user_count\n    user_count += 1  # Side effect!\n    return {\"name\": name, \"id\": user_count}\n\n# GOOD: Pure function\ndef create_user(name, user_id):\n    return {\"name\": name, \"id\": user_id}\n```\n\n## 6. Return Early\n\nUse early returns to reduce nesting:\n\n```python\n# BAD: Deep nesting\ndef process_order(order):\n    if order:\n        if order.is_valid:\n            if order.has_items:\n                # Process order\n                return True\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n\n# GOOD: Early returns\ndef process_order(order):\n    if not order:\n        return False\n    if not order.is_valid:\n        return False\n    if not order.has_items:\n        return False\n    \n    # Process order\n    return True\n```\n\n## 7. Use Type Hints\n\nType hints improve readability and catch bugs:\n\n```python\nfrom typing import List, Optional\n\ndef calculate_average(numbers: List[float]) -> float:\n    \"\"\"Calculate the average of a list of numbers.\"\"\"\n    if not numbers:\n        return 0.0\n    return sum(numbers) / len(numbers)\n\ndef find_user(user_id: int) -> Optional[dict]:\n    \"\"\"Find a user by ID. Returns None if not found.\"\"\"\n    users = {1: {\"name\": \"Alice\"}, 2: {\"name\": \"Bob\"}}\n    return users.get(user_id)\n```\n\n## 8. Write Testable Functions\n\nDesign functions that are easy to test:\n\n```python\n# BAD: Hard to test (depends on external state)\ndef get_current_temperature():\n    # Calls weather API directly\n    pass\n\n# GOOD: Testable (dependency injection)\ndef get_current_temperature(weather_service):\n    return weather_service.get_temperature()\n\n# Easy to test with mock service\nclass MockWeatherService:\n    def get_temperature(self):\n        return 72\n```\n\n## 9. Handle Errors Gracefully\n\n```python\n# BAD: Ignores errors\ndef divide(a, b):\n    return a / b  # Crashes on b=0\n\n# GOOD: Handle errors\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\n# Or return a default\ndef safe_divide(a, b, default=None):\n    if b == 0:\n        return default\n    return a / b\n```\n\n## 10. Document Your Functions\n\n```python\ndef process_payment(amount: float, currency: str = \"USD\") -> dict:\n    \"\"\"\n    Process a payment transaction.\n    \n    Args:\n        amount: The payment amount (must be positive).\n        currency: The currency code (default: USD).\n    \n    Returns:\n        A dictionary with transaction details.\n    \n    Raises:\n        ValueError: If amount is negative.\n    \n    Examples:\n        >>> process_payment(100.0)\n        {'status': 'success', 'amount': 100.0, 'currency': 'USD'}\n    \"\"\"\n    if amount < 0:\n        raise ValueError(\"Amount cannot be negative\")\n    return {\"status\": \"success\", \"amount\": amount, \"currency\": currency}\n```\n\n## Summary Checklist\n\n- [ ] Does one thing well\n- [ ] Has a descriptive name\n- [ ] Is short and focused\n- [ ] Has few parameters\n- [ ] Avoids side effects\n- [ ] Returns early when possible\n- [ ] Has type hints\n- [ ] Is testable\n- [ ] Handles errors\n- [ ] Is documented",
  "code": "# Function Best Practices\n# Writing clean, maintainable functions\n\n# 1. Single responsibility\ndef validate_email(email):\n    \"\"\"Check if email format is valid.\"\"\"\n    return '@' in email and '.' in email\n\ndef send_email(to, subject, body):\n    \"\"\"Send an email (simulated).\"\"\"\n    print(f\"Sending to {to}: {subject}\")\n\n# 2. Descriptive names\ndef calculate_discounted_price(original_price, discount_percent):\n    \"\"\"Calculate price after applying discount.\"\"\"\n    discount = original_price * (discount_percent / 100)\n    return original_price - discount\n\n# 3. Type hints for clarity\nfrom typing import List, Optional\n\ndef find_maximum(numbers: List[int]) -> Optional[int]:\n    \"\"\"Find the maximum value in a list.\"\"\"\n    if not numbers:\n        return None\n    return max(numbers)\n\n# 4. Early returns\ndef get_grade(score: int) -> str:\n    \"\"\"Convert numeric score to letter grade.\"\"\"\n    if score < 0 or score > 100:\n        return \"Invalid\"\n    if score >= 90:\n        return \"A\"\n    if score >= 80:\n        return \"B\"\n    if score >= 70:\n        return \"C\"\n    if score >= 60:\n        return \"D\"\n    return \"F\"\n\n# Test the functions\nprint(validate_email(\"test@example.com\"))\nprint(calculate_discounted_price(100, 20))\nprint(find_maximum([3, 1, 4, 1, 5, 9]))\nprint(get_grade(85))\n\n# Exercise: Refactor this function following best practices\ndef p(d):\n    t = 0\n    for i in d:\n        if i > 0:\n            t = t + i\n    return t\n"
}
