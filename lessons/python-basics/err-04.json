{
  "id": "err-04",
  "title": "Finally Block",
  "category": "Error Handling",
  "number": 84,
  "duration": "6 min read",
  "content": "## The Finally Block\n\nThe `finally` block contains code that will **always execute**, regardless of whether an exception occurred or not. It's used for cleanup operations that must happen no matter what.\n\n## Basic Syntax\n\n```python\ntry:\n    # Code that might raise an exception\n    risky_operation()\nexcept SomeError:\n    # Handle the error\n    print(\"Error occurred\")\nfinally:\n    # Always executes\n    print(\"Cleanup code here\")\n```\n\n## When Does Finally Run?\n\nThe `finally` block runs in ALL of these scenarios:\n\n```python\n# Scenario 1: No exception\ntry:\n    print(\"Success!\")\nfinally:\n    print(\"Finally runs\")  # Runs\n\n# Scenario 2: Exception caught\ntry:\n    raise ValueError(\"Error!\")\nexcept ValueError:\n    print(\"Caught!\")\nfinally:\n    print(\"Finally runs\")  # Runs\n\n# Scenario 3: Exception NOT caught\ntry:\n    raise RuntimeError(\"Uncaught!\")\nexcept ValueError:\n    print(\"Not caught\")\nfinally:\n    print(\"Finally runs\")  # Still runs!\n# RuntimeError propagates after finally\n\n# Scenario 4: Return statement in try\ndef example():\n    try:\n        return \"returning\"\n    finally:\n        print(\"Finally runs\")  # Runs before return!\n```\n\n## Common Use Cases\n\n### 1. File Handling\n\n```python\nfile = None\ntry:\n    file = open(\"data.txt\", \"r\")\n    content = file.read()\n    process(content)\nexcept FileNotFoundError:\n    print(\"File not found\")\nfinally:\n    if file:\n        file.close()\n        print(\"File closed\")\n```\n\n### 2. Database Connections\n\n```python\nconnection = None\ntry:\n    connection = database.connect()\n    cursor = connection.cursor()\n    cursor.execute(\"SELECT * FROM users\")\n    results = cursor.fetchall()\nexcept DatabaseError as e:\n    print(f\"Database error: {e}\")\nfinally:\n    if connection:\n        connection.close()\n        print(\"Connection closed\")\n```\n\n### 3. Lock Management\n\n```python\nimport threading\n\nlock = threading.Lock()\n\ndef thread_safe_operation():\n    lock.acquire()\n    try:\n        # Critical section\n        shared_resource.modify()\n    finally:\n        lock.release()  # Always release the lock!\n```\n\n### 4. Temporary State Changes\n\n```python\nimport os\n\ndef work_in_directory(path):\n    original_dir = os.getcwd()\n    try:\n        os.chdir(path)\n        # Do work in new directory\n        process_files()\n    finally:\n        os.chdir(original_dir)  # Always go back\n```\n\n## Try-Finally Without Except\n\nYou can use `finally` without `except`:\n\n```python\ndef read_file(filename):\n    file = open(filename)\n    try:\n        return file.read()\n    finally:\n        file.close()  # Always close, even if read() fails\n```\n\n## Complete Try Structure\n\n```python\ntry:\n    # Attempt risky operation\n    result = perform_operation()\nexcept SpecificError as e:\n    # Handle specific error\n    log_error(e)\n    result = default_value\nexcept Exception as e:\n    # Handle any other error\n    log_error(e)\n    raise  # Re-raise the exception\nelse:\n    # Only if no exception occurred\n    save_result(result)\nfinally:\n    # Always run cleanup\n    cleanup_resources()\n```\n\n## Finally and Return Values\n\n```python\ndef example():\n    try:\n        return \"try\"\n    finally:\n        print(\"finally executed\")\n        # Don't return from finally - it overrides try's return!\n\nresult = example()  # Prints \"finally executed\"\nprint(result)       # Prints \"try\"\n```\n\n**Warning:** Avoid returning from `finally`:\n\n```python\ndef bad_example():\n    try:\n        return \"try\"\n    finally:\n        return \"finally\"  # This overrides \"try\"!\n\nprint(bad_example())  # Prints \"finally\" - confusing!\n```\n\n## The Context Manager Alternative\n\nPython's `with` statement is often cleaner than `try-finally`:\n\n```python\n# Instead of this:\nfile = open(\"data.txt\")\ntry:\n    content = file.read()\nfinally:\n    file.close()\n\n# Use this:\nwith open(\"data.txt\") as file:\n    content = file.read()\n# File automatically closed\n```\n\n## When to Use Finally\n\n| Use Case | Example |\n|----------|----------|\n| Close files | `file.close()` |\n| Close connections | `conn.close()` |\n| Release locks | `lock.release()` |\n| Restore state | `os.chdir(original)` |\n| Stop timers | `timer.stop()` |\n| Log completion | `log(\"Operation complete\")` |\n\n## Best Practices\n\n1. **Keep finally simple** - Only cleanup code\n2. **Don't raise exceptions** in finally (can mask original error)\n3. **Don't return** from finally (overrides try/except returns)\n4. **Prefer context managers** when available\n5. **Check for None** before cleanup (resource might not be acquired)",
  "code": "# The Finally Block - Guaranteed Cleanup\n\n# Example 1: Basic finally behavior\nprint(\"=== Basic Finally ===\")\n\ndef demonstrate_finally(cause_error):\n    try:\n        print(\"Entering try block\")\n        if cause_error:\n            raise ValueError(\"Intentional error\")\n        print(\"No error occurred\")\n    except ValueError as e:\n        print(f\"Caught: {e}\")\n    finally:\n        print(\"Finally block ALWAYS runs\")\n    print(\"After try-except-finally\\n\")\n\ndemonstrate_finally(False)\ndemonstrate_finally(True)\n\n# Example 2: Resource cleanup simulation\nprint(\"\\n=== Resource Cleanup ===\")\n\nclass MockFile:\n    def __init__(self, name):\n        self.name = name\n        self.is_open = True\n        print(f\"Opened: {name}\")\n    \n    def read(self):\n        if not self.is_open:\n            raise ValueError(\"File is closed\")\n        return f\"Contents of {self.name}\"\n    \n    def close(self):\n        self.is_open = False\n        print(f\"Closed: {self.name}\")\n\ndef read_file_safely(should_fail=False):\n    file = MockFile(\"data.txt\")\n    try:\n        if should_fail:\n            raise IOError(\"Read failed!\")\n        content = file.read()\n        print(f\"Read: {content}\")\n        return content\n    except IOError as e:\n        print(f\"Error: {e}\")\n        return None\n    finally:\n        file.close()  # Always closes!\n\nread_file_safely(False)\nprint()\nread_file_safely(True)\n\n# Example 3: Finally with return\nprint(\"\\n=== Finally with Return ===\")\n\ndef get_value():\n    try:\n        print(\"About to return from try\")\n        return \"success\"\n    finally:\n        print(\"Finally runs before return!\")\n\nresult = get_value()\nprint(f\"Got: {result}\")\n\n# Example 4: Cleanup pattern\nprint(\"\\n=== Cleanup Pattern ===\")\n\ndef process_with_cleanup():\n    resources = []\n    try:\n        resources.append(\"Database connection\")\n        print(\"Connected to database\")\n        resources.append(\"File handle\")\n        print(\"Opened file\")\n        # Simulate work\n        print(\"Processing...\")\n    finally:\n        # Clean up in reverse order\n        while resources:\n            resource = resources.pop()\n            print(f\"Cleaned up: {resource}\")\n\nprocess_with_cleanup()"
}
